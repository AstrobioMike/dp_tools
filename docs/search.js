window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "dp_tools", "modulename": "dp_tools", "type": "module", "doc": "<p></p>\n"}, {"fullname": "dp_tools.bulkRNASeq", "modulename": "dp_tools.bulkRNASeq", "type": "module", "doc": "<p></p>\n"}, {"fullname": "dp_tools.bulkRNASeq.checks", "modulename": "dp_tools.bulkRNASeq.checks", "type": "module", "doc": "<p></p>\n"}, {"fullname": "dp_tools.bulkRNASeq.checks.formatfloat", "modulename": "dp_tools.bulkRNASeq.checks", "qualname": "formatfloat", "type": "function", "doc": "<p></p>\n", "signature": "(x)", "funcdef": "def"}, {"fullname": "dp_tools.bulkRNASeq.checks.pformat", "modulename": "dp_tools.bulkRNASeq.checks", "qualname": "pformat", "type": "function", "doc": "<p></p>\n", "signature": "(original_dictionary, function)", "funcdef": "def"}, {"fullname": "dp_tools.bulkRNASeq.checks.convert_nan_to_zero", "modulename": "dp_tools.bulkRNASeq.checks", "qualname": "convert_nan_to_zero", "type": "function", "doc": "<p>Convert any Nan into zero</p>\n", "signature": "(input: Dict[str, Union[int, float]]) -> Dict", "funcdef": "def"}, {"fullname": "dp_tools.bulkRNASeq.checks.stat_string_to_value", "modulename": "dp_tools.bulkRNASeq.checks", "qualname": "stat_string_to_value", "type": "function", "doc": "<p>\"stat1 + stat2\" should search and sum the stats</p>\n", "signature": "(\n    stat_string: str,\n    mqcData: dp_tools.core.entity_model.ModuleLevelMQC\n) -> float", "funcdef": "def"}, {"fullname": "dp_tools.bulkRNASeq.checks.nonNull", "modulename": "dp_tools.bulkRNASeq.checks", "qualname": "nonNull", "type": "function", "doc": "<p></p>\n", "signature": "(df: pandas.core.frame.DataFrame) -> bool", "funcdef": "def"}, {"fullname": "dp_tools.bulkRNASeq.checks.nonNegative", "modulename": "dp_tools.bulkRNASeq.checks", "qualname": "nonNegative", "type": "function", "doc": "<p>This ignores null values, use nonNull to validate that condition</p>\n", "signature": "(df: pandas.core.frame.DataFrame) -> bool", "funcdef": "def"}, {"fullname": "dp_tools.bulkRNASeq.checks.onlyAllowedValues", "modulename": "dp_tools.bulkRNASeq.checks", "qualname": "onlyAllowedValues", "type": "function", "doc": "<p>This ignores null values, use nonNull to validate that condition</p>\n", "signature": "(df: pandas.core.frame.DataFrame, allowed_values: list) -> bool", "funcdef": "def"}, {"fullname": "dp_tools.bulkRNASeq.checks.check_forward_and_reverse_reads_counts_match", "modulename": "dp_tools.bulkRNASeq.checks", "qualname": "check_forward_and_reverse_reads_counts_match", "type": "function", "doc": "<p></p>\n", "signature": "(\n    fwd_reads: dp_tools.components.components.RawReadsComponent,\n    rev_reads: dp_tools.components.components.RawReadsComponent\n) -> dp_tools.core.check_model.FlagEntry", "funcdef": "def"}, {"fullname": "dp_tools.bulkRNASeq.checks.check_file_exists", "modulename": "dp_tools.bulkRNASeq.checks", "qualname": "check_file_exists", "type": "function", "doc": "<p></p>\n", "signature": "(file: pathlib.Path) -> dp_tools.core.check_model.FlagEntry", "funcdef": "def"}, {"fullname": "dp_tools.bulkRNASeq.checks.check_fastqgz_file_contents", "modulename": "dp_tools.bulkRNASeq.checks", "qualname": "check_fastqgz_file_contents", "type": "function", "doc": "<p>Check fastqgz by:</p>\n\n<ol>\n<li>Decompressing as a stream of lines.</li>\n<li>Affirming expected headers (every 4th line) look correct.</li>\n</ol>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>file</strong>:  Input fastqGZ file path</li>\n<li><strong>count_lines_to_check</strong>:  Maximum number of lines to check. Setting this to a negative value will remove the limit</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A required fields-only flag entry dictionary</p>\n</blockquote>\n", "signature": "(\n    file: pathlib.Path,\n    count_lines_to_check: int\n) -> dp_tools.core.check_model.FlagEntry", "funcdef": "def"}, {"fullname": "dp_tools.bulkRNASeq.checks.check_bam_file_integrity", "modulename": "dp_tools.bulkRNASeq.checks", "qualname": "check_bam_file_integrity", "type": "function", "doc": "<p>Uses http://www.htslib.org/doc/samtools-quickcheck.html</p>\n", "signature": "(\n    file: pathlib.Path,\n    samtools_bin: pathlib.Path\n) -> dp_tools.core.check_model.FlagEntry", "funcdef": "def"}, {"fullname": "dp_tools.bulkRNASeq.checks.check_thresholds", "modulename": "dp_tools.bulkRNASeq.checks", "qualname": "check_thresholds", "type": "function", "doc": "<p></p>\n", "signature": "(\n    component: dp_tools.core.entity_model.TemplateComponent,\n    mqc_key: str,\n    stat_string: str,\n    thresholds: list[dict]\n) -> dp_tools.core.check_model.FlagEntry", "funcdef": "def"}, {"fullname": "dp_tools.bulkRNASeq.checks.check_metadata_attributes_exist", "modulename": "dp_tools.bulkRNASeq.checks", "qualname": "check_metadata_attributes_exist", "type": "function", "doc": "<p></p>\n", "signature": "(\n    dataset: dp_tools.bulkRNASeq.entity.BulkRNASeqDataset,\n    expected_attrs: list[str]\n) -> dp_tools.core.check_model.FlagEntry", "funcdef": "def"}, {"fullname": "dp_tools.bulkRNASeq.checks.check_for_outliers", "modulename": "dp_tools.bulkRNASeq.checks", "qualname": "check_for_outliers", "type": "function", "doc": "<p></p>\n", "signature": "(\n    dataset: dp_tools.core.entity_model.TemplateDataset,\n    sample_component: str,\n    mqc_module: str,\n    mqc_plot: str,\n    mqc_keys: list[str],\n    thresholds: list[dict]\n) -> dp_tools.core.check_model.FlagEntryWithOutliers", "funcdef": "def"}, {"fullname": "dp_tools.bulkRNASeq.checks.check_genebody_coverage_output", "modulename": "dp_tools.bulkRNASeq.checks", "qualname": "check_genebody_coverage_output", "type": "function", "doc": "<p></p>\n", "signature": "(input_dir: pathlib.Path)", "funcdef": "def"}, {"fullname": "dp_tools.bulkRNASeq.checks.check_inner_distance_output", "modulename": "dp_tools.bulkRNASeq.checks", "qualname": "check_inner_distance_output", "type": "function", "doc": "<p></p>\n", "signature": "(input_dir: pathlib.Path)", "funcdef": "def"}, {"fullname": "dp_tools.bulkRNASeq.checks.check_strandedness_assessable_from_infer_experiment", "modulename": "dp_tools.bulkRNASeq.checks", "qualname": "check_strandedness_assessable_from_infer_experiment", "type": "function", "doc": "<p></p>\n", "signature": "(\n    dataset: dp_tools.bulkRNASeq.entity.BulkRNASeqDataset,\n    stranded_assessment_range: dict[str, float],\n    unstranded_assessment_range: dict[str, float],\n    valid_dominant_strandedness_assessments: list[str]\n) -> dp_tools.core.check_model.FlagEntry", "funcdef": "def"}, {"fullname": "dp_tools.bulkRNASeq.entity", "modulename": "dp_tools.bulkRNASeq.entity", "type": "module", "doc": "<p></p>\n"}, {"fullname": "dp_tools.bulkRNASeq.entity.ASSAY", "modulename": "dp_tools.bulkRNASeq.entity", "qualname": "ASSAY", "type": "class", "doc": "<p>An enumeration.</p>\n", "bases": "enum.Enum"}, {"fullname": "dp_tools.bulkRNASeq.entity.ASSAY.BulkRNASeq", "modulename": "dp_tools.bulkRNASeq.entity", "qualname": "ASSAY.BulkRNASeq", "type": "variable", "doc": "<p></p>\n", "default_value": " = <ASSAY.BulkRNASeq: 1>"}, {"fullname": "dp_tools.bulkRNASeq.entity.BulkRNASeqSample", "modulename": "dp_tools.bulkRNASeq.entity", "qualname": "BulkRNASeqSample", "type": "class", "doc": "<p>Abstract class for samples</p>\n", "bases": "dp_tools.core.entity_model.TemplateSample"}, {"fullname": "dp_tools.bulkRNASeq.entity.BulkRNASeqSample.__init__", "modulename": "dp_tools.bulkRNASeq.entity", "qualname": "BulkRNASeqSample.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    base: dp_tools.core.entity_model.BaseSample,\n    assay_type: str = 'BulkRNASeq',\n    rawForwardReads: Union[dp_tools.core.entity_model.EmptyComponent, dp_tools.components.components.RawReadsComponent] = <factory>,\n    rawReverseReads: Union[dp_tools.core.entity_model.EmptyComponent, dp_tools.components.components.RawReadsComponent] = <factory>,\n    trimForwardReads: Union[dp_tools.core.entity_model.EmptyComponent, dp_tools.components.components.TrimReadsComponent] = <factory>,\n    trimReverseReads: Union[dp_tools.core.entity_model.EmptyComponent, dp_tools.components.components.TrimReadsComponent] = <factory>,\n    rawReads: Union[dp_tools.core.entity_model.EmptyComponent, dp_tools.components.components.RawReadsComponent] = <factory>,\n    trimReads: Union[dp_tools.core.entity_model.EmptyComponent, dp_tools.components.components.TrimReadsComponent] = <factory>,\n    genomeAlignments: Union[dp_tools.core.entity_model.EmptyComponent, dp_tools.components.components.GenomeAlignments] = <factory>,\n    rSeQCAnalysis: Union[dp_tools.core.entity_model.EmptyComponent, dp_tools.components.components.RSeQCAnalysis] = <factory>,\n    geneCounts: Union[dp_tools.core.entity_model.EmptyComponent, dp_tools.components.components.GeneCounts] = <factory>\n)", "funcdef": "def"}, {"fullname": "dp_tools.bulkRNASeq.entity.BulkRNASeqSample.assay_type", "modulename": "dp_tools.bulkRNASeq.entity", "qualname": "BulkRNASeqSample.assay_type", "type": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": " = 'BulkRNASeq'"}, {"fullname": "dp_tools.bulkRNASeq.entity.BulkRNASeqDataset", "modulename": "dp_tools.bulkRNASeq.entity", "qualname": "BulkRNASeqDataset", "type": "class", "doc": "<p>BulkRNASeqDataset(base: dp_tools.core.entity_model.BaseDataset, assay_type: str = 'BulkRNASeq', metadata: Union[dp_tools.core.entity_model.EmptyComponent, dp_tools.components.components.BulkRNASeqMetadataComponent] = <factory>, geneCounts: Union[dp_tools.core.entity_model.EmptyComponent, dp_tools.components.components.DatasetGeneCounts] = <factory>, normalizedGeneCounts: Union[dp_tools.core.entity_model.EmptyComponent, dp_tools.components.components.NormalizedGeneCounts] = <factory>, differentialGeneExpression: Union[dp_tools.core.entity_model.EmptyComponent, dp_tools.components.components.DifferentialGeneExpression] = <factory>, differentialGeneExpressionERCC: Union[dp_tools.core.entity_model.EmptyComponent, dp_tools.components.components.DifferentialGeneExpression] = <factory>)</p>\n", "bases": "dp_tools.core.entity_model.TemplateDataset"}, {"fullname": "dp_tools.bulkRNASeq.entity.BulkRNASeqDataset.__init__", "modulename": "dp_tools.bulkRNASeq.entity", "qualname": "BulkRNASeqDataset.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    base: dp_tools.core.entity_model.BaseDataset,\n    assay_type: str = 'BulkRNASeq',\n    metadata: Union[dp_tools.core.entity_model.EmptyComponent, dp_tools.components.components.BulkRNASeqMetadataComponent] = <factory>,\n    geneCounts: Union[dp_tools.core.entity_model.EmptyComponent, dp_tools.components.components.DatasetGeneCounts] = <factory>,\n    normalizedGeneCounts: Union[dp_tools.core.entity_model.EmptyComponent, dp_tools.components.components.NormalizedGeneCounts] = <factory>,\n    differentialGeneExpression: Union[dp_tools.core.entity_model.EmptyComponent, dp_tools.components.components.DifferentialGeneExpression] = <factory>,\n    differentialGeneExpressionERCC: Union[dp_tools.core.entity_model.EmptyComponent, dp_tools.components.components.DifferentialGeneExpression] = <factory>\n)", "funcdef": "def"}, {"fullname": "dp_tools.bulkRNASeq.entity.BulkRNASeqDataset.assay_type", "modulename": "dp_tools.bulkRNASeq.entity", "qualname": "BulkRNASeqDataset.assay_type", "type": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": " = 'BulkRNASeq'"}, {"fullname": "dp_tools.bulkRNASeq.entity.BulkRNASeqDataset.expected_sample_class", "modulename": "dp_tools.bulkRNASeq.entity", "qualname": "BulkRNASeqDataset.expected_sample_class", "type": "class", "doc": "<p>Abstract class for samples</p>\n", "bases": "dp_tools.core.entity_model.TemplateSample"}, {"fullname": "dp_tools.bulkRNASeq.loaders", "modulename": "dp_tools.bulkRNASeq.loaders", "type": "module", "doc": "<p>Functions for loading into data model objects </p>\n\n<h6 id=\"loaders-should\">Loaders SHOULD</h6>\n\n<blockquote>\n  <ul>\n  <li>run validation on the dataSystem object</li>\n  <li>return a dataSystem object</li>\n  </ul>\n</blockquote>\n"}, {"fullname": "dp_tools.bulkRNASeq.loaders.load_config", "modulename": "dp_tools.bulkRNASeq.loaders", "qualname": "load_config", "type": "function", "doc": "<p></p>\n", "signature": "(config: Union[str, pathlib.Path]) -> dict", "funcdef": "def"}, {"fullname": "dp_tools.bulkRNASeq.loaders.load_BulkRNASeq_STAGE_00", "modulename": "dp_tools.bulkRNASeq.loaders", "qualname": "load_BulkRNASeq_STAGE_00", "type": "function", "doc": "<p>config is either an string version referring to a packaged config file or a path to a local config file.</p>\n", "signature": "(\n    root_path: pathlib.Path,\n    config: Union[str, pathlib.Path] = 'Latest',\n    dataSystem_name: str = None,\n    stack: bool = False,\n    validation_enabled: bool = True\n)", "funcdef": "def"}, {"fullname": "dp_tools.bulkRNASeq.loaders.load_BulkRNASeq_STAGE_01", "modulename": "dp_tools.bulkRNASeq.loaders", "qualname": "load_BulkRNASeq_STAGE_01", "type": "function", "doc": "<p>Load data that should be present into stage 01 (TG-PreProc)</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>dataSystem</strong>:  The dataSystem as loaded through STAGE 00</li>\n</ul>\n", "signature": "(\n    root_path: pathlib.Path,\n    dataSystem: dp_tools.core.entity_model.TemplateDataSystem,\n    config: Union[str, pathlib.Path] = 'Latest',\n    stack: bool = False,\n    validation_enabled: bool = True\n)", "funcdef": "def"}, {"fullname": "dp_tools.bulkRNASeq.loaders.load_BulkRNASeq_STAGE_02", "modulename": "dp_tools.bulkRNASeq.loaders", "qualname": "load_BulkRNASeq_STAGE_02", "type": "function", "doc": "<p>Load data that should be present into stage 02 (GenomeAlignment)</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>dataSystem</strong>:  The dataSystem as loaded through STAGE 02</li>\n</ul>\n", "signature": "(\n    root_path: pathlib.Path,\n    dataSystem: dp_tools.core.entity_model.TemplateDataSystem,\n    config: Union[str, pathlib.Path] = 'Latest',\n    stack: bool = False,\n    validation_enabled: bool = True\n)", "funcdef": "def"}, {"fullname": "dp_tools.bulkRNASeq.loaders.load_BulkRNASeq_STAGE_0201", "modulename": "dp_tools.bulkRNASeq.loaders", "qualname": "load_BulkRNASeq_STAGE_0201", "type": "function", "doc": "<p>Load data that should be present into stage 0201 (RSeQCAnalysis)</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>dataSystem</strong>:  The dataSystem as loaded through STAGE 0201</li>\n</ul>\n", "signature": "(\n    root_path: pathlib.Path,\n    dataSystem: dp_tools.core.entity_model.TemplateDataSystem,\n    config: Union[str, pathlib.Path] = 'Latest',\n    stack: bool = False,\n    validation_enabled: bool = True\n)", "funcdef": "def"}, {"fullname": "dp_tools.bulkRNASeq.loaders.load_BulkRNASeq_STAGE_03", "modulename": "dp_tools.bulkRNASeq.loaders", "qualname": "load_BulkRNASeq_STAGE_03", "type": "function", "doc": "<p>Load data that should be present into stage 03 (RSEM Counts)</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>dataSystem</strong>:  The dataSystem as loaded through STAGE 03</li>\n</ul>\n", "signature": "(\n    root_path: pathlib.Path,\n    dataSystem: dp_tools.core.entity_model.TemplateDataSystem,\n    config: Union[str, pathlib.Path] = 'Latest',\n    stack: bool = False,\n    validation_enabled: bool = True\n)", "funcdef": "def"}, {"fullname": "dp_tools.bulkRNASeq.loaders.load_BulkRNASeq_STAGE_04", "modulename": "dp_tools.bulkRNASeq.loaders", "qualname": "load_BulkRNASeq_STAGE_04", "type": "function", "doc": "<p>Load data that should be present into stage 03 (RSEM Counts)</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>dataSystem</strong>:  The dataSystem as loaded through STAGE 03</li>\n</ul>\n", "signature": "(\n    root_path: pathlib.Path,\n    dataSystem: dp_tools.core.entity_model.TemplateDataSystem,\n    config: Union[str, pathlib.Path] = 'Latest',\n    stack: bool = False,\n    validation_enabled: bool = True\n)", "funcdef": "def"}, {"fullname": "dp_tools.bulkRNASeq.locaters", "modulename": "dp_tools.bulkRNASeq.locaters", "type": "module", "doc": "<p>Tools for finding specific paths </p>\n\n<p>These should rely on configuratble files to accommodate changing directory structures.\nFor now, the regexes will be hardcoded.</p>\n\n<h6 id=\"such-locators-should\">Such Locators SHOULD</h6>\n\n<blockquote>\n  <ul>\n  <li>have find function that returns the path</li>\n  <li>search starting at root data directory</li>\n  <li>any RE patterns should be relative to the search_path</li>\n  </ul>\n</blockquote>\n"}, {"fullname": "dp_tools.bulkRNASeq.locaters.log", "modulename": "dp_tools.bulkRNASeq.locaters", "qualname": "log", "type": "variable", "doc": "<p>TODO: implement as a class to achieve the following functionality:</p>\n\n<ul>\n<li>Track all unlocated data assets to report likely data assets missing from data-model\n@dataclass\nclass Locator():\nall_data_assets: ClassVar[Set] = field(init=False, repr=False)\nroot_dir: Path\ndata_asset_config: dict</li>\n</ul>\n", "default_value": " = <Logger dp_tools.bulkRNASeq.locaters (WARNING)>"}, {"fullname": "dp_tools.bulkRNASeq.locaters.Locator", "modulename": "dp_tools.bulkRNASeq.locaters", "qualname": "Locator", "type": "class", "doc": "<p>Locator(root_dir: pathlib.Path, data_asset_config: dict, validation_enabled: bool = True, return_parsed_config_as_metadata: bool = True)</p>\n"}, {"fullname": "dp_tools.bulkRNASeq.locaters.Locator.__init__", "modulename": "dp_tools.bulkRNASeq.locaters", "qualname": "Locator.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    root_dir: pathlib.Path,\n    data_asset_config: dict,\n    validation_enabled: bool = True,\n    return_parsed_config_as_metadata: bool = True\n)", "funcdef": "def"}, {"fullname": "dp_tools.bulkRNASeq.locaters.Locator.validation_enabled", "modulename": "dp_tools.bulkRNASeq.locaters", "qualname": "Locator.validation_enabled", "type": "variable", "doc": "<p></p>\n", "annotation": ": bool", "default_value": " = True"}, {"fullname": "dp_tools.bulkRNASeq.locaters.Locator.return_parsed_config_as_metadata", "modulename": "dp_tools.bulkRNASeq.locaters", "qualname": "Locator.return_parsed_config_as_metadata", "type": "variable", "doc": "<p></p>\n", "annotation": ": bool", "default_value": " = True"}, {"fullname": "dp_tools.bulkRNASeq.locaters.Locator.find_data_asset_path", "modulename": "dp_tools.bulkRNASeq.locaters", "qualname": "Locator.find_data_asset_path", "type": "function", "doc": "<p>Find a data asset\n**template_kwargs include substrings like sample and dataset.\nThis can be 'overloaded' but will throw an exception if a requested template value\nis not provided.</p>\n\n<p>Uses the data assets yaml format</p>\n", "signature": "(\n    self,\n    config_key: str,\n    search: bool = True,\n    glob: bool = False,\n    **template_kwargs\n)", "funcdef": "def"}, {"fullname": "dp_tools.bulkRNASeq.vv_protocols", "modulename": "dp_tools.bulkRNASeq.vv_protocols", "type": "module", "doc": "<p></p>\n"}, {"fullname": "dp_tools.bulkRNASeq.vv_protocols.STAGE", "modulename": "dp_tools.bulkRNASeq.vv_protocols", "qualname": "STAGE", "type": "class", "doc": "<p>An enumeration.</p>\n", "bases": "enum.Enum"}, {"fullname": "dp_tools.bulkRNASeq.vv_protocols.STAGE.Demultiplexed", "modulename": "dp_tools.bulkRNASeq.vv_protocols", "qualname": "STAGE.Demultiplexed", "type": "variable", "doc": "<p></p>\n", "default_value": " = <STAGE.Demultiplexed: 0>"}, {"fullname": "dp_tools.bulkRNASeq.vv_protocols.STAGE.Reads_PreProcessed", "modulename": "dp_tools.bulkRNASeq.vv_protocols", "qualname": "STAGE.Reads_PreProcessed", "type": "variable", "doc": "<p></p>\n", "default_value": " = <STAGE.Reads_PreProcessed: 1>"}, {"fullname": "dp_tools.bulkRNASeq.vv_protocols.STAGE.GenomeAligned", "modulename": "dp_tools.bulkRNASeq.vv_protocols", "qualname": "STAGE.GenomeAligned", "type": "variable", "doc": "<p></p>\n", "default_value": " = <STAGE.GenomeAligned: 2>"}, {"fullname": "dp_tools.bulkRNASeq.vv_protocols.STAGE.RSeQCAnalysis", "modulename": "dp_tools.bulkRNASeq.vv_protocols", "qualname": "STAGE.RSeQCAnalysis", "type": "variable", "doc": "<p></p>\n", "default_value": " = <STAGE.RSeQCAnalysis: 2.01>"}, {"fullname": "dp_tools.bulkRNASeq.vv_protocols.STAGE.GeneCounted", "modulename": "dp_tools.bulkRNASeq.vv_protocols", "qualname": "STAGE.GeneCounted", "type": "variable", "doc": "<p></p>\n", "default_value": " = <STAGE.GeneCounted: 3>"}, {"fullname": "dp_tools.bulkRNASeq.vv_protocols.STAGE.DGE", "modulename": "dp_tools.bulkRNASeq.vv_protocols", "qualname": "STAGE.DGE", "type": "variable", "doc": "<p></p>\n", "default_value": " = <STAGE.DGE: 4>"}, {"fullname": "dp_tools.bulkRNASeq.vv_protocols.STAGE.get_all_preceeding", "modulename": "dp_tools.bulkRNASeq.vv_protocols", "qualname": "STAGE.get_all_preceeding", "type": "function", "doc": "<p></p>\n", "signature": "(cls, query_stage)", "funcdef": "def"}, {"fullname": "dp_tools.bulkRNASeq.vv_protocols.validate_bulkRNASeq", "modulename": "dp_tools.bulkRNASeq.vv_protocols", "qualname": "validate_bulkRNASeq", "type": "function", "doc": "<p></p>\n", "signature": "(\n    dataset: dp_tools.bulkRNASeq.entity.BulkRNASeqDataset,\n    config_path: pathlib.Path,\n    report_args: dict = None,\n    protocol_args: dict = None,\n    defer_run: bool = False\n) -> Union[dp_tools.core.check_model.ValidationProtocol, dp_tools.core.check_model.ValidationProtocol.Report]", "funcdef": "def"}, {"fullname": "dp_tools.components", "modulename": "dp_tools.components", "type": "module", "doc": "<p></p>\n"}, {"fullname": "dp_tools.components.components", "modulename": "dp_tools.components.components", "type": "module", "doc": "<p></p>\n"}, {"fullname": "dp_tools.components.components.RawReadsComponent", "modulename": "dp_tools.components.components", "qualname": "RawReadsComponent", "type": "class", "doc": "<p>RawReadsComponent(fastqGZ: dp_tools.core.entity_model.DataFile, base: dp_tools.core.entity_model.BaseComponent, fastQCmultiQCDirZIP: Optional[dp_tools.core.entity_model.DataFile] = None, fastqcReportHTML: Optional[dp_tools.core.entity_model.DataFile] = None, fastqcReportZIP: Optional[dp_tools.core.entity_model.DataFile] = None)</p>\n", "bases": "dp_tools.core.entity_model.TemplateComponent"}, {"fullname": "dp_tools.components.components.RawReadsComponent.__init__", "modulename": "dp_tools.components.components", "qualname": "RawReadsComponent.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    fastqGZ: dp_tools.core.entity_model.DataFile,\n    base: dp_tools.core.entity_model.BaseComponent,\n    fastQCmultiQCDirZIP: Optional[dp_tools.core.entity_model.DataFile] = None,\n    fastqcReportHTML: Optional[dp_tools.core.entity_model.DataFile] = None,\n    fastqcReportZIP: Optional[dp_tools.core.entity_model.DataFile] = None\n)", "funcdef": "def"}, {"fullname": "dp_tools.components.components.RawReadsComponent.fastQCmultiQCDirZIP", "modulename": "dp_tools.components.components", "qualname": "RawReadsComponent.fastQCmultiQCDirZIP", "type": "variable", "doc": "<p></p>\n", "annotation": ": Optional[dp_tools.core.entity_model.DataFile]", "default_value": " = None"}, {"fullname": "dp_tools.components.components.RawReadsComponent.fastqcReportHTML", "modulename": "dp_tools.components.components", "qualname": "RawReadsComponent.fastqcReportHTML", "type": "variable", "doc": "<p></p>\n", "annotation": ": Optional[dp_tools.core.entity_model.DataFile]", "default_value": " = None"}, {"fullname": "dp_tools.components.components.RawReadsComponent.fastqcReportZIP", "modulename": "dp_tools.components.components", "qualname": "RawReadsComponent.fastqcReportZIP", "type": "variable", "doc": "<p></p>\n", "annotation": ": Optional[dp_tools.core.entity_model.DataFile]", "default_value": " = None"}, {"fullname": "dp_tools.components.components.TrimReadsComponent", "modulename": "dp_tools.components.components", "qualname": "TrimReadsComponent", "type": "class", "doc": "<p>TrimReadsComponent(fastqGZ: dp_tools.core.entity_model.DataFile, base: dp_tools.core.entity_model.BaseComponent, fastQCmultiQCDirZIP: Optional[dp_tools.core.entity_model.DataFile] = None, fastqcReportHTML: Optional[dp_tools.core.entity_model.DataFile] = None, fastqcReportZIP: Optional[dp_tools.core.entity_model.DataFile] = None, trimmingReportTXT: Optional[dp_tools.core.entity_model.DataFile] = None, trimmingMultiQCDirZIP: Optional[dp_tools.core.entity_model.DataFile] = None)</p>\n", "bases": "dp_tools.core.entity_model.TemplateComponent"}, {"fullname": "dp_tools.components.components.TrimReadsComponent.__init__", "modulename": "dp_tools.components.components", "qualname": "TrimReadsComponent.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    fastqGZ: dp_tools.core.entity_model.DataFile,\n    base: dp_tools.core.entity_model.BaseComponent,\n    fastQCmultiQCDirZIP: Optional[dp_tools.core.entity_model.DataFile] = None,\n    fastqcReportHTML: Optional[dp_tools.core.entity_model.DataFile] = None,\n    fastqcReportZIP: Optional[dp_tools.core.entity_model.DataFile] = None,\n    trimmingReportTXT: Optional[dp_tools.core.entity_model.DataFile] = None,\n    trimmingMultiQCDirZIP: Optional[dp_tools.core.entity_model.DataFile] = None\n)", "funcdef": "def"}, {"fullname": "dp_tools.components.components.TrimReadsComponent.fastQCmultiQCDirZIP", "modulename": "dp_tools.components.components", "qualname": "TrimReadsComponent.fastQCmultiQCDirZIP", "type": "variable", "doc": "<p></p>\n", "annotation": ": Optional[dp_tools.core.entity_model.DataFile]", "default_value": " = None"}, {"fullname": "dp_tools.components.components.TrimReadsComponent.fastqcReportHTML", "modulename": "dp_tools.components.components", "qualname": "TrimReadsComponent.fastqcReportHTML", "type": "variable", "doc": "<p></p>\n", "annotation": ": Optional[dp_tools.core.entity_model.DataFile]", "default_value": " = None"}, {"fullname": "dp_tools.components.components.TrimReadsComponent.fastqcReportZIP", "modulename": "dp_tools.components.components", "qualname": "TrimReadsComponent.fastqcReportZIP", "type": "variable", "doc": "<p></p>\n", "annotation": ": Optional[dp_tools.core.entity_model.DataFile]", "default_value": " = None"}, {"fullname": "dp_tools.components.components.TrimReadsComponent.trimmingReportTXT", "modulename": "dp_tools.components.components", "qualname": "TrimReadsComponent.trimmingReportTXT", "type": "variable", "doc": "<p></p>\n", "annotation": ": Optional[dp_tools.core.entity_model.DataFile]", "default_value": " = None"}, {"fullname": "dp_tools.components.components.TrimReadsComponent.trimmingMultiQCDirZIP", "modulename": "dp_tools.components.components", "qualname": "TrimReadsComponent.trimmingMultiQCDirZIP", "type": "variable", "doc": "<p></p>\n", "annotation": ": Optional[dp_tools.core.entity_model.DataFile]", "default_value": " = None"}, {"fullname": "dp_tools.components.components.BulkRNASeqMetadataComponent", "modulename": "dp_tools.components.components", "qualname": "BulkRNASeqMetadataComponent", "type": "class", "doc": "<p>BulkRNASeqMetadataComponent(base: dp_tools.core.entity_model.BaseComponent, runsheet: Optional[dp_tools.core.entity_model.DataFile] = None, ISAarchive: Optional[dp_tools.core.entity_model.DataFile] = None)</p>\n", "bases": "dp_tools.core.entity_model.TemplateComponent"}, {"fullname": "dp_tools.components.components.BulkRNASeqMetadataComponent.__init__", "modulename": "dp_tools.components.components", "qualname": "BulkRNASeqMetadataComponent.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    base: dp_tools.core.entity_model.BaseComponent,\n    runsheet: Optional[dp_tools.core.entity_model.DataFile] = None,\n    ISAarchive: Optional[dp_tools.core.entity_model.DataFile] = None\n)", "funcdef": "def"}, {"fullname": "dp_tools.components.components.BulkRNASeqMetadataComponent.runsheet", "modulename": "dp_tools.components.components", "qualname": "BulkRNASeqMetadataComponent.runsheet", "type": "variable", "doc": "<p></p>\n", "annotation": ": Optional[dp_tools.core.entity_model.DataFile]", "default_value": " = None"}, {"fullname": "dp_tools.components.components.BulkRNASeqMetadataComponent.ISAarchive", "modulename": "dp_tools.components.components", "qualname": "BulkRNASeqMetadataComponent.ISAarchive", "type": "variable", "doc": "<p></p>\n", "annotation": ": Optional[dp_tools.core.entity_model.DataFile]", "default_value": " = None"}, {"fullname": "dp_tools.components.components.BulkRNASeqMetadataComponent.factor_groups", "modulename": "dp_tools.components.components", "qualname": "BulkRNASeqMetadataComponent.factor_groups", "type": "variable", "doc": "<p>Returns sample wise dictionary of sample name to concatenated factor group.</p>\n\n<p>The concatenated group will be consistent with the BulkRNASeq Deseq2 script formatting for constrasts.</p>\n\n<h6 id=\"this-means\">This means</h6>\n\n<blockquote>\n  <ul>\n  <li>replacing within factor 'spaces' with periods</li>\n  <li>wrapping the factor in quotes</li>\n  <li>joining factors into factor groups with ' &amp; '</li>\n  <li>finally joining factors groups to derive pairwise-contrasts with 'v'</li>\n  </ul>\n</blockquote>\n", "annotation": ": Dict[str, str]"}, {"fullname": "dp_tools.components.components.BulkRNASeqMetadataComponent.contrasts", "modulename": "dp_tools.components.components", "qualname": "BulkRNASeqMetadataComponent.contrasts", "type": "variable", "doc": "<p>Returns sample wise dictionary of sample name to concatenated factor group.</p>\n\n<p>Creates a constrast dataframe in the same fashion as the DESEQ2 contrasts table:</p>\n\n<ul>\n<li>determine all permutations of existing factor groups</li>\n<li>format with header for each permutation in format: {factorGroup1}v{factorGroup2}</li>\n<li>format with two rows for each column in format:\n<ul>\n<li>r1: factorGroup1.replace(' &amp; ','...').replace(' ','.').replace(',','.').replace('(',\"\").replace(')',\"\")</li>\n<li>r2: factorGroup1.replace(' &amp; ','...').replace(' ','.').replace(',','.').replace('(',\"\").replace(')',\"\")</li>\n</ul></li>\n</ul>\n", "annotation": ": pandas.core.frame.DataFrame"}, {"fullname": "dp_tools.components.components.BulkRNASeqMetadataComponent.organism", "modulename": "dp_tools.components.components", "qualname": "BulkRNASeqMetadataComponent.organism", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "dp_tools.components.components.BulkRNASeqMetadataComponent.fetch_isa_files_external", "modulename": "dp_tools.components.components", "qualname": "BulkRNASeqMetadataComponent.fetch_isa_files_external", "type": "function", "doc": "<p></p>\n", "signature": "(ISAarchive: pathlib.Path) -> set[pathlib.Path]", "funcdef": "def"}, {"fullname": "dp_tools.components.components.BulkRNASeqMetadataComponent.fetch_isa_files", "modulename": "dp_tools.components.components", "qualname": "BulkRNASeqMetadataComponent.fetch_isa_files", "type": "function", "doc": "<p>Unzips the ISA archive in a temporary directory and reports files</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>List of individual file paths</p>\n</blockquote>\n", "signature": "(self) -> Set[pathlib.Path]", "funcdef": "def"}, {"fullname": "dp_tools.components.components.BulkRNASeqMetadataComponent.isa_investigation_subtables", "modulename": "dp_tools.components.components", "qualname": "BulkRNASeqMetadataComponent.isa_investigation_subtables", "type": "variable", "doc": "<p></p>\n", "annotation": ": dict[str, pandas.core.frame.DataFrame]"}, {"fullname": "dp_tools.components.components.GenomeAlignments", "modulename": "dp_tools.components.components", "qualname": "GenomeAlignments", "type": "class", "doc": "<p>GenomeAlignments(base: dp_tools.core.entity_model.BaseComponent, alignedToTranscriptomeBam: Optional[dp_tools.core.entity_model.DataFile] = None, alignedSortedByCoordBam: Optional[dp_tools.core.entity_model.DataFile] = None, alignedSortedByCoordResortedBam: Optional[dp_tools.core.entity_model.DataFile] = None, alignedSortedByCoordResortedBamIndex: Optional[dp_tools.core.entity_model.DataFile] = None, logFinal: Optional[dp_tools.core.entity_model.DataFile] = None, logProgress: Optional[dp_tools.core.entity_model.DataFile] = None, logFull: Optional[dp_tools.core.entity_model.DataFile] = None, sjTab: Optional[dp_tools.core.entity_model.DataFile] = None, multiQCDirZIP: Optional[dp_tools.core.entity_model.DataFile] = None)</p>\n", "bases": "dp_tools.core.entity_model.TemplateComponent"}, {"fullname": "dp_tools.components.components.GenomeAlignments.__init__", "modulename": "dp_tools.components.components", "qualname": "GenomeAlignments.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    base: dp_tools.core.entity_model.BaseComponent,\n    alignedToTranscriptomeBam: Optional[dp_tools.core.entity_model.DataFile] = None,\n    alignedSortedByCoordBam: Optional[dp_tools.core.entity_model.DataFile] = None,\n    alignedSortedByCoordResortedBam: Optional[dp_tools.core.entity_model.DataFile] = None,\n    alignedSortedByCoordResortedBamIndex: Optional[dp_tools.core.entity_model.DataFile] = None,\n    logFinal: Optional[dp_tools.core.entity_model.DataFile] = None,\n    logProgress: Optional[dp_tools.core.entity_model.DataFile] = None,\n    logFull: Optional[dp_tools.core.entity_model.DataFile] = None,\n    sjTab: Optional[dp_tools.core.entity_model.DataFile] = None,\n    multiQCDirZIP: Optional[dp_tools.core.entity_model.DataFile] = None\n)", "funcdef": "def"}, {"fullname": "dp_tools.components.components.GenomeAlignments.alignedToTranscriptomeBam", "modulename": "dp_tools.components.components", "qualname": "GenomeAlignments.alignedToTranscriptomeBam", "type": "variable", "doc": "<p></p>\n", "annotation": ": Optional[dp_tools.core.entity_model.DataFile]", "default_value": " = None"}, {"fullname": "dp_tools.components.components.GenomeAlignments.alignedSortedByCoordBam", "modulename": "dp_tools.components.components", "qualname": "GenomeAlignments.alignedSortedByCoordBam", "type": "variable", "doc": "<p></p>\n", "annotation": ": Optional[dp_tools.core.entity_model.DataFile]", "default_value": " = None"}, {"fullname": "dp_tools.components.components.GenomeAlignments.alignedSortedByCoordResortedBam", "modulename": "dp_tools.components.components", "qualname": "GenomeAlignments.alignedSortedByCoordResortedBam", "type": "variable", "doc": "<p></p>\n", "annotation": ": Optional[dp_tools.core.entity_model.DataFile]", "default_value": " = None"}, {"fullname": "dp_tools.components.components.GenomeAlignments.alignedSortedByCoordResortedBamIndex", "modulename": "dp_tools.components.components", "qualname": "GenomeAlignments.alignedSortedByCoordResortedBamIndex", "type": "variable", "doc": "<p></p>\n", "annotation": ": Optional[dp_tools.core.entity_model.DataFile]", "default_value": " = None"}, {"fullname": "dp_tools.components.components.GenomeAlignments.logFinal", "modulename": "dp_tools.components.components", "qualname": "GenomeAlignments.logFinal", "type": "variable", "doc": "<p></p>\n", "annotation": ": Optional[dp_tools.core.entity_model.DataFile]", "default_value": " = None"}, {"fullname": "dp_tools.components.components.GenomeAlignments.logProgress", "modulename": "dp_tools.components.components", "qualname": "GenomeAlignments.logProgress", "type": "variable", "doc": "<p></p>\n", "annotation": ": Optional[dp_tools.core.entity_model.DataFile]", "default_value": " = None"}, {"fullname": "dp_tools.components.components.GenomeAlignments.logFull", "modulename": "dp_tools.components.components", "qualname": "GenomeAlignments.logFull", "type": "variable", "doc": "<p></p>\n", "annotation": ": Optional[dp_tools.core.entity_model.DataFile]", "default_value": " = None"}, {"fullname": "dp_tools.components.components.GenomeAlignments.sjTab", "modulename": "dp_tools.components.components", "qualname": "GenomeAlignments.sjTab", "type": "variable", "doc": "<p></p>\n", "annotation": ": Optional[dp_tools.core.entity_model.DataFile]", "default_value": " = None"}, {"fullname": "dp_tools.components.components.GenomeAlignments.multiQCDirZIP", "modulename": "dp_tools.components.components", "qualname": "GenomeAlignments.multiQCDirZIP", "type": "variable", "doc": "<p></p>\n", "annotation": ": Optional[dp_tools.core.entity_model.DataFile]", "default_value": " = None"}, {"fullname": "dp_tools.components.components.GeneCounts", "modulename": "dp_tools.components.components", "qualname": "GeneCounts", "type": "class", "doc": "<p>Based on RSEM output gene counts</p>\n", "bases": "dp_tools.core.entity_model.TemplateComponent"}, {"fullname": "dp_tools.components.components.GeneCounts.__init__", "modulename": "dp_tools.components.components", "qualname": "GeneCounts.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    base: dp_tools.core.entity_model.BaseComponent,\n    multiQCDirZIP: Optional[dp_tools.core.entity_model.DataFile] = None,\n    genesResults: Optional[dp_tools.core.entity_model.DataFile] = None,\n    isoformsResults: Optional[dp_tools.core.entity_model.DataFile] = None,\n    statDir: Optional[dp_tools.core.entity_model.DataDir] = None\n)", "funcdef": "def"}, {"fullname": "dp_tools.components.components.GeneCounts.multiQCDirZIP", "modulename": "dp_tools.components.components", "qualname": "GeneCounts.multiQCDirZIP", "type": "variable", "doc": "<p></p>\n", "annotation": ": Optional[dp_tools.core.entity_model.DataFile]", "default_value": " = None"}, {"fullname": "dp_tools.components.components.GeneCounts.genesResults", "modulename": "dp_tools.components.components", "qualname": "GeneCounts.genesResults", "type": "variable", "doc": "<p></p>\n", "annotation": ": Optional[dp_tools.core.entity_model.DataFile]", "default_value": " = None"}, {"fullname": "dp_tools.components.components.GeneCounts.isoformsResults", "modulename": "dp_tools.components.components", "qualname": "GeneCounts.isoformsResults", "type": "variable", "doc": "<p></p>\n", "annotation": ": Optional[dp_tools.core.entity_model.DataFile]", "default_value": " = None"}, {"fullname": "dp_tools.components.components.GeneCounts.statDir", "modulename": "dp_tools.components.components", "qualname": "GeneCounts.statDir", "type": "variable", "doc": "<p></p>\n", "annotation": ": Optional[dp_tools.core.entity_model.DataDir]", "default_value": " = None"}, {"fullname": "dp_tools.components.components.DatasetGeneCounts", "modulename": "dp_tools.components.components", "qualname": "DatasetGeneCounts", "type": "class", "doc": "<p>DatasetGeneCounts(base: dp_tools.core.entity_model.BaseComponent, numNonZero: Optional[dp_tools.core.entity_model.DataFile] = None, unnormalizedCounts: Optional[dp_tools.core.entity_model.DataFile] = None)</p>\n", "bases": "dp_tools.core.entity_model.TemplateComponent"}, {"fullname": "dp_tools.components.components.DatasetGeneCounts.__init__", "modulename": "dp_tools.components.components", "qualname": "DatasetGeneCounts.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    base: dp_tools.core.entity_model.BaseComponent,\n    numNonZero: Optional[dp_tools.core.entity_model.DataFile] = None,\n    unnormalizedCounts: Optional[dp_tools.core.entity_model.DataFile] = None\n)", "funcdef": "def"}, {"fullname": "dp_tools.components.components.DatasetGeneCounts.numNonZero", "modulename": "dp_tools.components.components", "qualname": "DatasetGeneCounts.numNonZero", "type": "variable", "doc": "<p></p>\n", "annotation": ": Optional[dp_tools.core.entity_model.DataFile]", "default_value": " = None"}, {"fullname": "dp_tools.components.components.DatasetGeneCounts.unnormalizedCounts", "modulename": "dp_tools.components.components", "qualname": "DatasetGeneCounts.unnormalizedCounts", "type": "variable", "doc": "<p></p>\n", "annotation": ": Optional[dp_tools.core.entity_model.DataFile]", "default_value": " = None"}, {"fullname": "dp_tools.components.components.RSeQCAnalysis", "modulename": "dp_tools.components.components", "qualname": "RSeQCAnalysis", "type": "class", "doc": "<p>RSeQCAnalysis(base: dp_tools.core.entity_model.BaseComponent, geneBodyCoverageMultiQCDirZIP: Optional[dp_tools.core.entity_model.DataFile] = None, geneBodyCoverageOut: Optional[dp_tools.core.entity_model.DataDir] = None, inferExperimentMultiQCDirZIP: Optional[dp_tools.core.entity_model.DataFile] = None, inferExperimentOut: Optional[dp_tools.core.entity_model.DataFile] = None, innerDistanceMultiQCDirZIP: Optional[dp_tools.core.entity_model.DataFile] = None, innerDistanceOut: Optional[dp_tools.core.entity_model.DataDir] = None, readDistributionMultiQCDirZIP: Optional[dp_tools.core.entity_model.DataFile] = None, readDistributionOut: Optional[dp_tools.core.entity_model.DataFile] = None)</p>\n", "bases": "dp_tools.core.entity_model.TemplateComponent"}, {"fullname": "dp_tools.components.components.RSeQCAnalysis.__init__", "modulename": "dp_tools.components.components", "qualname": "RSeQCAnalysis.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    base: dp_tools.core.entity_model.BaseComponent,\n    geneBodyCoverageMultiQCDirZIP: Optional[dp_tools.core.entity_model.DataFile] = None,\n    geneBodyCoverageOut: Optional[dp_tools.core.entity_model.DataDir] = None,\n    inferExperimentMultiQCDirZIP: Optional[dp_tools.core.entity_model.DataFile] = None,\n    inferExperimentOut: Optional[dp_tools.core.entity_model.DataFile] = None,\n    innerDistanceMultiQCDirZIP: Optional[dp_tools.core.entity_model.DataFile] = None,\n    innerDistanceOut: Optional[dp_tools.core.entity_model.DataDir] = None,\n    readDistributionMultiQCDirZIP: Optional[dp_tools.core.entity_model.DataFile] = None,\n    readDistributionOut: Optional[dp_tools.core.entity_model.DataFile] = None\n)", "funcdef": "def"}, {"fullname": "dp_tools.components.components.RSeQCAnalysis.geneBodyCoverageMultiQCDirZIP", "modulename": "dp_tools.components.components", "qualname": "RSeQCAnalysis.geneBodyCoverageMultiQCDirZIP", "type": "variable", "doc": "<p></p>\n", "annotation": ": Optional[dp_tools.core.entity_model.DataFile]", "default_value": " = None"}, {"fullname": "dp_tools.components.components.RSeQCAnalysis.geneBodyCoverageOut", "modulename": "dp_tools.components.components", "qualname": "RSeQCAnalysis.geneBodyCoverageOut", "type": "variable", "doc": "<p></p>\n", "annotation": ": Optional[dp_tools.core.entity_model.DataDir]", "default_value": " = None"}, {"fullname": "dp_tools.components.components.RSeQCAnalysis.inferExperimentMultiQCDirZIP", "modulename": "dp_tools.components.components", "qualname": "RSeQCAnalysis.inferExperimentMultiQCDirZIP", "type": "variable", "doc": "<p></p>\n", "annotation": ": Optional[dp_tools.core.entity_model.DataFile]", "default_value": " = None"}, {"fullname": "dp_tools.components.components.RSeQCAnalysis.inferExperimentOut", "modulename": "dp_tools.components.components", "qualname": "RSeQCAnalysis.inferExperimentOut", "type": "variable", "doc": "<p></p>\n", "annotation": ": Optional[dp_tools.core.entity_model.DataFile]", "default_value": " = None"}, {"fullname": "dp_tools.components.components.RSeQCAnalysis.innerDistanceMultiQCDirZIP", "modulename": "dp_tools.components.components", "qualname": "RSeQCAnalysis.innerDistanceMultiQCDirZIP", "type": "variable", "doc": "<p></p>\n", "annotation": ": Optional[dp_tools.core.entity_model.DataFile]", "default_value": " = None"}, {"fullname": "dp_tools.components.components.RSeQCAnalysis.innerDistanceOut", "modulename": "dp_tools.components.components", "qualname": "RSeQCAnalysis.innerDistanceOut", "type": "variable", "doc": "<p></p>\n", "annotation": ": Optional[dp_tools.core.entity_model.DataDir]", "default_value": " = None"}, {"fullname": "dp_tools.components.components.RSeQCAnalysis.readDistributionMultiQCDirZIP", "modulename": "dp_tools.components.components", "qualname": "RSeQCAnalysis.readDistributionMultiQCDirZIP", "type": "variable", "doc": "<p></p>\n", "annotation": ": Optional[dp_tools.core.entity_model.DataFile]", "default_value": " = None"}, {"fullname": "dp_tools.components.components.RSeQCAnalysis.readDistributionOut", "modulename": "dp_tools.components.components", "qualname": "RSeQCAnalysis.readDistributionOut", "type": "variable", "doc": "<p></p>\n", "annotation": ": Optional[dp_tools.core.entity_model.DataFile]", "default_value": " = None"}, {"fullname": "dp_tools.components.components.NormalizedGeneCounts", "modulename": "dp_tools.components.components", "qualname": "NormalizedGeneCounts", "type": "class", "doc": "<p>NormalizedGeneCounts(base: dp_tools.core.entity_model.BaseComponent, erccNormalizedCountsCSV: Optional[dp_tools.core.entity_model.DataFile] = None, normalizedCountsCSV: Optional[dp_tools.core.entity_model.DataFile] = None, sampleTableCSV: Optional[dp_tools.core.entity_model.DataFile] = None, unnormalizedCountsCSV: Optional[dp_tools.core.entity_model.DataFile] = None)</p>\n", "bases": "dp_tools.core.entity_model.TemplateComponent"}, {"fullname": "dp_tools.components.components.NormalizedGeneCounts.__init__", "modulename": "dp_tools.components.components", "qualname": "NormalizedGeneCounts.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    base: dp_tools.core.entity_model.BaseComponent,\n    erccNormalizedCountsCSV: Optional[dp_tools.core.entity_model.DataFile] = None,\n    normalizedCountsCSV: Optional[dp_tools.core.entity_model.DataFile] = None,\n    sampleTableCSV: Optional[dp_tools.core.entity_model.DataFile] = None,\n    unnormalizedCountsCSV: Optional[dp_tools.core.entity_model.DataFile] = None\n)", "funcdef": "def"}, {"fullname": "dp_tools.components.components.NormalizedGeneCounts.erccNormalizedCountsCSV", "modulename": "dp_tools.components.components", "qualname": "NormalizedGeneCounts.erccNormalizedCountsCSV", "type": "variable", "doc": "<p></p>\n", "annotation": ": Optional[dp_tools.core.entity_model.DataFile]", "default_value": " = None"}, {"fullname": "dp_tools.components.components.NormalizedGeneCounts.normalizedCountsCSV", "modulename": "dp_tools.components.components", "qualname": "NormalizedGeneCounts.normalizedCountsCSV", "type": "variable", "doc": "<p></p>\n", "annotation": ": Optional[dp_tools.core.entity_model.DataFile]", "default_value": " = None"}, {"fullname": "dp_tools.components.components.NormalizedGeneCounts.sampleTableCSV", "modulename": "dp_tools.components.components", "qualname": "NormalizedGeneCounts.sampleTableCSV", "type": "variable", "doc": "<p></p>\n", "annotation": ": Optional[dp_tools.core.entity_model.DataFile]", "default_value": " = None"}, {"fullname": "dp_tools.components.components.NormalizedGeneCounts.unnormalizedCountsCSV", "modulename": "dp_tools.components.components", "qualname": "NormalizedGeneCounts.unnormalizedCountsCSV", "type": "variable", "doc": "<p></p>\n", "annotation": ": Optional[dp_tools.core.entity_model.DataFile]", "default_value": " = None"}, {"fullname": "dp_tools.components.components.DifferentialGeneExpression", "modulename": "dp_tools.components.components", "qualname": "DifferentialGeneExpression", "type": "class", "doc": "<p>DifferentialGeneExpression(base: dp_tools.core.entity_model.BaseComponent, contrastsCSV: Optional[dp_tools.core.entity_model.DataFile] = None, annotatedTableCSV: Optional[dp_tools.core.entity_model.DataFile] = None, visualizationTableCSV: Optional[dp_tools.core.entity_model.DataFile] = None, visualizationPCATableCSV: Optional[dp_tools.core.entity_model.DataFile] = None)</p>\n", "bases": "dp_tools.core.entity_model.TemplateComponent"}, {"fullname": "dp_tools.components.components.DifferentialGeneExpression.__init__", "modulename": "dp_tools.components.components", "qualname": "DifferentialGeneExpression.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    base: dp_tools.core.entity_model.BaseComponent,\n    contrastsCSV: Optional[dp_tools.core.entity_model.DataFile] = None,\n    annotatedTableCSV: Optional[dp_tools.core.entity_model.DataFile] = None,\n    visualizationTableCSV: Optional[dp_tools.core.entity_model.DataFile] = None,\n    visualizationPCATableCSV: Optional[dp_tools.core.entity_model.DataFile] = None\n)", "funcdef": "def"}, {"fullname": "dp_tools.components.components.DifferentialGeneExpression.contrastsCSV", "modulename": "dp_tools.components.components", "qualname": "DifferentialGeneExpression.contrastsCSV", "type": "variable", "doc": "<p></p>\n", "annotation": ": Optional[dp_tools.core.entity_model.DataFile]", "default_value": " = None"}, {"fullname": "dp_tools.components.components.DifferentialGeneExpression.annotatedTableCSV", "modulename": "dp_tools.components.components", "qualname": "DifferentialGeneExpression.annotatedTableCSV", "type": "variable", "doc": "<p></p>\n", "annotation": ": Optional[dp_tools.core.entity_model.DataFile]", "default_value": " = None"}, {"fullname": "dp_tools.components.components.DifferentialGeneExpression.visualizationTableCSV", "modulename": "dp_tools.components.components", "qualname": "DifferentialGeneExpression.visualizationTableCSV", "type": "variable", "doc": "<p></p>\n", "annotation": ": Optional[dp_tools.core.entity_model.DataFile]", "default_value": " = None"}, {"fullname": "dp_tools.components.components.DifferentialGeneExpression.visualizationPCATableCSV", "modulename": "dp_tools.components.components", "qualname": "DifferentialGeneExpression.visualizationPCATableCSV", "type": "variable", "doc": "<p></p>\n", "annotation": ": Optional[dp_tools.core.entity_model.DataFile]", "default_value": " = None"}, {"fullname": "dp_tools.config", "modulename": "dp_tools.config", "type": "module", "doc": "<p></p>\n"}, {"fullname": "dp_tools.config.schemas", "modulename": "dp_tools.config.schemas", "type": "module", "doc": "<p>Schemas for validation \nUses Schema to allow usage of validation functions</p>\n"}, {"fullname": "dp_tools.core", "modulename": "dp_tools.core", "type": "module", "doc": "<p></p>\n"}, {"fullname": "dp_tools.core.check_model", "modulename": "dp_tools.core.check_model", "type": "module", "doc": "<p></p>\n"}, {"fullname": "dp_tools.core.check_model.FlagCode", "modulename": "dp_tools.core.check_model", "qualname": "FlagCode", "type": "class", "doc": "<p>Maps a flag code to a severity level.</p>\n\n<h6 id=\"note\">Note</h6>\n\n<blockquote>\n  <p>Severity of flag codes are as follows:</p>\n  \n  <p>DEV_UNHANDLED &gt; HALT &gt; RED &gt; YELLOW &gt; GREEN &gt; INFO &gt; SKIPPED</p>\n</blockquote>\n\n<h6 id=\"example\">Example</h6>\n\n<blockquote>\n  <p>Comparing flags will compare severity levels::</p>\n\n<pre><code>FlagCode.RED &gt; FlagCode.GREEN\n# should return True\n</code></pre>\n</blockquote>\n", "bases": "enum.Enum"}, {"fullname": "dp_tools.core.check_model.FlagCode.DEV_UNHANDLED", "modulename": "dp_tools.core.check_model", "qualname": "FlagCode.DEV_UNHANDLED", "type": "variable", "doc": "<p>Never used directly, instead used when an unhandled exceptions is raised in the check function</p>\n", "default_value": " = <FlagCode.DEV_UNHANDLED: 90>"}, {"fullname": "dp_tools.core.check_model.FlagCode.HALT", "modulename": "dp_tools.core.check_model", "qualname": "FlagCode.HALT", "type": "variable", "doc": "<p>Denotes an issue problematic enough to merit halting an ongoing process immediately. Note: Actually issuing any halt commands is outside the scope of validation protocol itself.</p>\n", "default_value": " = <FlagCode.HALT: 80>"}, {"fullname": "dp_tools.core.check_model.FlagCode.RED", "modulename": "dp_tools.core.check_model", "qualname": "FlagCode.RED", "type": "variable", "doc": "<p>A severe issue. Likely requiring further manual investigation.</p>\n", "default_value": " = <FlagCode.RED: 50>"}, {"fullname": "dp_tools.core.check_model.FlagCode.YELLOW", "modulename": "dp_tools.core.check_model", "qualname": "FlagCode.YELLOW", "type": "variable", "doc": "<p>A moderate/minor issue. May require further manual investigation especially if concentrated around a specific component.</p>\n", "default_value": " = <FlagCode.YELLOW: 30>"}, {"fullname": "dp_tools.core.check_model.FlagCode.GREEN", "modulename": "dp_tools.core.check_model", "qualname": "FlagCode.GREEN", "type": "variable", "doc": "<p>Indicates no issues found during the check.</p>\n", "default_value": " = <FlagCode.GREEN: 20>"}, {"fullname": "dp_tools.core.check_model.FlagCode.INFO", "modulename": "dp_tools.core.check_model", "qualname": "FlagCode.INFO", "type": "variable", "doc": "<p>Denotes the results of a check without an issue catching mechanism. May be used to report information in the flag table.</p>\n", "default_value": " = <FlagCode.INFO: 10>"}, {"fullname": "dp_tools.core.check_model.FlagCode.SKIPPED", "modulename": "dp_tools.core.check_model", "qualname": "FlagCode.SKIPPED", "type": "variable", "doc": "<p>Never used directly, instead is the flag code for skipped checks</p>\n", "default_value": " = <FlagCode.SKIPPED: 1>"}, {"fullname": "dp_tools.core.check_model.FlagEntry", "modulename": "dp_tools.core.check_model", "qualname": "FlagEntry", "type": "class", "doc": "<p>A dictionary reporting results of a check.</p>\n", "bases": "typing.TypedDict"}, {"fullname": "dp_tools.core.check_model.FlagEntry.code", "modulename": "dp_tools.core.check_model", "qualname": "FlagEntry.code", "type": "variable", "doc": "<p>Assessment of the check's success/failure</p>\n", "annotation": ": dp_tools.core.check_model.FlagCode"}, {"fullname": "dp_tools.core.check_model.FlagEntry.message", "modulename": "dp_tools.core.check_model", "qualname": "FlagEntry.message", "type": "variable", "doc": "<p>A check specific message describing why the code was issued</p>\n", "annotation": ": str"}, {"fullname": "dp_tools.core.check_model.FlagEntryWithOutliers", "modulename": "dp_tools.core.check_model", "qualname": "FlagEntryWithOutliers", "type": "class", "doc": "<p>Extension of FlagEntry that includes outliers information.</p>\n", "bases": "builtins.dict"}, {"fullname": "dp_tools.core.check_model.FlagEntryWithOutliers.outliers", "modulename": "dp_tools.core.check_model", "qualname": "FlagEntryWithOutliers.outliers", "type": "variable", "doc": "<p>A dictionary describing outliers found during the check</p>\n", "annotation": ": dict[str, dict[str, dict[str, str]]]"}, {"fullname": "dp_tools.core.check_model.ValidationProtocol", "modulename": "dp_tools.core.check_model", "qualname": "ValidationProtocol", "type": "class", "doc": "<p>A validation protocol.</p>\n\n<p>Validation protocols are used to connect check function, function configuration\nand inputs to form a check queue.</p>\n\n<p>The check queue can then be printed and/or run.</p>\n\n<p>Finally, the protocol object includes reporting functions\nto present the results of those checks.</p>\n\n<h6 id=\"example\">Example</h6>\n\n<blockquote>\n  <p>An entire sample validation protocol run::</p>\n\n<pre><code>from dp_tools.core.check_model import ValidationProtocol, FlagCode\n\ncar = {\n    \"wheels\": [\n        {\"isFlat\": False},\n        {\"isFlat\": False},\n        {\"isFlat\": True},  # uh oh\n        {\"isFlat\": False},\n    ],\n    \"engineOkay\": True,\n    \"gasTank\": 100,\n    \"isElectric\": False,\n    # doesn't apply so this entry isn't included\n    # \"charge\":0\n}\n\n\ndef check_if_wheel_flat(wheel: dict):\n    if not wheel[\"isFlat\"]:\n        code = FlagCode.GREEN\n        message = \"Engine looks good\"\n    else:\n        code = FlagCode.HALT1\n        message = \"Engine needs work!\"\n    return {\"code\": code, \"message\": message}\n\n\ndef check_engine_okay(car: dict):\n    if car[\"engineOkay\"]:\n        code = FlagCode.GREEN\n        message = \"Engine looks good\"\n    else:\n        code = FlagCode.HALT1\n        message = \"Engine needs work!\"\n    return {\"code\": code, \"message\": message}\n\n\ndef check_gas(cur_gas: float, minimum_gas: float):\n    if cur_gas &gt;= minimum_gas:\n        code = FlagCode.GREEN\n        message = f\"Gas tank is at {cur_gas}. Which is above {minimum_gas}\"\n    else:\n        code = FlagCode.HALT1\n        message = (\n            f\"Gas tank needs a fill up! Current: {cur_gas}. Minimum: {minimum_gas}\"\n        )\n    return {\"code\": code, \"message\": message}\n\n\ndef check_charge(cur_charge: float, minimum_charge: float):\n    if cur_charge &gt;= minimum_charge:\n        code = FlagCode.GREEN\n        message = \"Charge looks good\"\n    else:\n        code = FlagCode.HALT1\n        message = \"Needs a charge!\"\n    return {\"code\": code, \"message\": message}\n\n\nvp = ValidationProtocol()\nwith vp.component_start(\n    name=\"PreDrive Check\",\n    description=\"Make sure the car is ready for the trip\",\n):\n\n    with vp.component_start(\n        name=\"Engine\",\n        description=\"Make sure the engine is running fine\",\n    ):\n        with vp.payload(payloads=[{\"car\": car}]) as ADD:\n            ADD(check_engine_okay)\n\n    with vp.component_start(\n        name=\"Tires\",\n        description=\"Make sure the tires are road ready\",\n    ):\n        with vp.payload(\n            payloads=[\n                {\"wheel\": car[\"wheels\"][0]},\n                {\"wheel\": car[\"wheels\"][1]},\n                {\"wheel\": car[\"wheels\"][2]},\n                {\"wheel\": car[\"wheels\"][3]},\n            ]\n        ) as ADD:\n            ADD(check_if_wheel_flat)\n\n    with vp.component_start(\n        name=\"Fuel\",\n        description=\"Check gas or charge is sufficent\",\n    ):\n        # NOTE: lambda is used in payload to defer evaluation conditioned\n        #   on whether the check is run or skipped.\n        with vp.payload(payloads=[{\"cur_gas\": lambda: car[\"gasTank\"]}]) as ADD:\n            ADD(check_gas, config={\"minimum_gas\": 95}, skip=(car[\"isElectric\"]))\n\n        with vp.payload(payloads=[{\"cur_charge\": lambda: car[\"charge\"]}]) as ADD:\n            ADD(\n                check_charge,\n                config={\"minimum_charge\": 95},\n                skip=(not car[\"isElectric\"]),\n            )\n\n    # Now printing the queued checks\n    print(vp.queued_checks())\n\n    print(\"********************************\")\n    # Running the checks\n    vp.run()\n\n    # And showing the results\n    print(vp.report()[\"flag_table\"])\n\n    print(\"Individual Flag Row\")\n    print(vp.report()[\"flag_table\"].iloc[5].to_dict())\n</code></pre>\n</blockquote>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>skip_components (list, optional):</strong>  Component names to skip. Defaults to None.</li>\n<li><strong>run_components (list, optional):</strong>  Components name to run. Defaults to None.\nIf no components are specified, all components will run (except those explicitly\nincluded in the 'skip_components')</li>\n</ul>\n"}, {"fullname": "dp_tools.core.check_model.ValidationProtocol.__init__", "modulename": "dp_tools.core.check_model", "qualname": "ValidationProtocol.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, skip_components: list = None, run_components: list = None)", "funcdef": "def"}, {"fullname": "dp_tools.core.check_model.ValidationProtocol.component_start", "modulename": "dp_tools.core.check_model", "qualname": "ValidationProtocol.component_start", "type": "function", "doc": "<p>Start a new component block.\nThe component will be automatically placed in the component tree.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>name (str):</strong>  Used to describe the component and for skipping by name</li>\n<li><strong>description (str):</strong>  Currently unused.\nWill be used to be a explanation of the overall goal of the component's checks</li>\n<li><strong>skip (bool, optional):</strong>  Controls whether all checks under the component should be skipped.\nThis includes all child component checks. Defaults to False.</li>\n</ul>\n", "signature": "(self, name: str, description: str, skip: bool = False)", "funcdef": "def"}, {"fullname": "dp_tools.core.check_model.ValidationProtocol.payload", "modulename": "dp_tools.core.check_model", "qualname": "ValidationProtocol.payload", "type": "function", "doc": "<p>Provides a context to queue multiple checks with a list of arguments.\nE.g. can be used to supply multiple files to a single 'check_file_exists' function.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>payloads (list[dict]):</strong>  A list of keyword arguments to pass to every check in the context</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Callable: The protocol's add function.\n      Solely for convenience to allow 'add()' vs 'ValidationProtocol.add()'</p>\n</blockquote>\n", "signature": "(self, payloads: list[dict]) -> Callable", "funcdef": "def"}, {"fullname": "dp_tools.core.check_model.ValidationProtocol.add", "modulename": "dp_tools.core.check_model", "qualname": "ValidationProtocol.add", "type": "function", "doc": "<p>Adds the check to the queue for each payload.\nPayload can be either supplied directly on the add invocation\nor in a wrapping 'ValidationProtocol.payload' block.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>fcn (Callable[..., FlagEntry]):</strong>  The function to queue for each payload.</li>\n<li><strong>payloads (dict, optional):</strong>  A direct payload to supply to the fcn, defaults to None.\nFalls back to a wrapped 'ValidationProtocol.payload' if available</li>\n<li><strong>skip (bool, optional):</strong>  Denotes whether the queued check will be skipped. Defaults to False</li>\n<li><strong>config (dict, optional):</strong>  Additional function keyword arguments. Defaults to None.\nThese are considered independent of the items that need validation (which should be supplied via payload)</li>\n<li><strong>description (str, optional):</strong>  A description of the check function. Defaults to function name.\nShould be used if the function name doesn't adequately describe what is being checked.</li>\n</ul>\n", "signature": "(\n    self,\n    fcn: Callable[..., dp_tools.core.check_model.FlagEntry],\n    payloads: dict = None,\n    skip: bool = False,\n    config: dict = None,\n    description: str = None\n)", "funcdef": "def"}, {"fullname": "dp_tools.core.check_model.ValidationProtocol.queued_checks", "modulename": "dp_tools.core.check_model", "qualname": "ValidationProtocol.queued_checks", "type": "function", "doc": "<p>Returns a print-friendly string describing the queued checks.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>include_individual_checks (bool, optional):</strong>  Controls whether individual checks should be included. Defaults to True.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>str: A human friendly description of the queued checks.</p>\n</blockquote>\n", "signature": "(self, include_individual_checks: bool = True) -> str", "funcdef": "def"}, {"fullname": "dp_tools.core.check_model.ValidationProtocol.run", "modulename": "dp_tools.core.check_model", "qualname": "ValidationProtocol.run", "type": "function", "doc": "<p>Runs all queued checks not marked as skipped.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "dp_tools.core.check_model.ValidationProtocol.Report", "modulename": "dp_tools.core.check_model", "qualname": "ValidationProtocol.Report", "type": "class", "doc": "<p>A dictionary that acts as a container for sub-reports.</p>\n", "bases": "typing.TypedDict"}, {"fullname": "dp_tools.core.check_model.ValidationProtocol.Report.flag_table", "modulename": "dp_tools.core.check_model", "qualname": "ValidationProtocol.Report.flag_table", "type": "variable", "doc": "<p>A dataframe with each flag as a row.</p>\n", "annotation": ": pandas.core.frame.DataFrame"}, {"fullname": "dp_tools.core.check_model.ValidationProtocol.Report.outliers", "modulename": "dp_tools.core.check_model", "qualname": "ValidationProtocol.Report.outliers", "type": "variable", "doc": "<p>A dataframe with outlier entities as rows and associated components as columns.</p>\n", "annotation": ": pandas.core.frame.DataFrame"}, {"fullname": "dp_tools.core.check_model.ValidationProtocol.report", "modulename": "dp_tools.core.check_model", "qualname": "ValidationProtocol.report", "type": "function", "doc": "<p>Tabulates the results of the executed protocol.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>include_skipped (bool, optional):</strong>  Controls whether the flag table should include skipped flags. Defaults to True.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>ValidationProtocol.Report: A report of all check results</p>\n</blockquote>\n", "signature": "(\n    self,\n    include_skipped: bool = True\n) -> dp_tools.core.check_model.ValidationProtocol.Report", "funcdef": "def"}, {"fullname": "dp_tools.core.configuration", "modulename": "dp_tools.core.configuration", "type": "module", "doc": "<p></p>\n"}, {"fullname": "dp_tools.core.configuration.load_full_config", "modulename": "dp_tools.core.configuration", "qualname": "load_full_config", "type": "function", "doc": "<p></p>\n", "signature": "(config: Union[str, pathlib.Path]) -> dict", "funcdef": "def"}, {"fullname": "dp_tools.core.configuration.load_config", "modulename": "dp_tools.core.configuration", "qualname": "load_config", "type": "function", "doc": "<p>Load yaml configuration file. Allows loading from either:</p>\n\n<ul>\n<li>A prepackaged configuration file using a tuple of ('config_type','config_version') (e.g. ('bulkRNASeq','Latest'), ('microarray','0'))</li>\n<li>A configuration file supplied as a Path object</li>\n</ul>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>config</strong>:  Configuration file to load</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A dictionary of the full configuration</p>\n</blockquote>\n", "signature": "(config: Union[tuple[str, str], pathlib.Path]) -> dict", "funcdef": "def"}, {"fullname": "dp_tools.core.entity_model", "modulename": "dp_tools.core.entity_model", "type": "module", "doc": "<p></p>\n"}, {"fullname": "dp_tools.core.entity_model.get_id", "modulename": "dp_tools.core.entity_model", "qualname": "get_id", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "dp_tools.core.entity_model.DataFile", "modulename": "dp_tools.core.entity_model", "qualname": "DataFile", "type": "class", "doc": "<p>A class for keeping track of files</p>\n"}, {"fullname": "dp_tools.core.entity_model.DataFile.__init__", "modulename": "dp_tools.core.entity_model", "qualname": "DataFile.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    path: pathlib.Path,\n    metadata: dict = <factory>,\n    dummy_md5sum: bool = False,\n    check_exists: bool = True\n)", "funcdef": "def"}, {"fullname": "dp_tools.core.entity_model.DataFile.dummy_md5sum", "modulename": "dp_tools.core.entity_model", "qualname": "DataFile.dummy_md5sum", "type": "variable", "doc": "<p></p>\n", "annotation": ": bool", "default_value": " = False"}, {"fullname": "dp_tools.core.entity_model.DataFile.check_exists", "modulename": "dp_tools.core.entity_model", "qualname": "DataFile.check_exists", "type": "variable", "doc": "<p></p>\n", "annotation": ": bool", "default_value": " = True"}, {"fullname": "dp_tools.core.entity_model.DataFile.compute_md5sum", "modulename": "dp_tools.core.entity_model", "qualname": "DataFile.compute_md5sum", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "dp_tools.core.entity_model.DataDir", "modulename": "dp_tools.core.entity_model", "qualname": "DataDir", "type": "class", "doc": "<p>A class for keeping track of directories\nBoth multiQC and RSEM include examples of things better tracked as directories; however, more granual loading can be achieved with DataFile.</p>\n"}, {"fullname": "dp_tools.core.entity_model.DataDir.__init__", "modulename": "dp_tools.core.entity_model", "qualname": "DataDir.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    path: pathlib.Path,\n    metadata: dict = <factory>,\n    check_exists: bool = True\n)", "funcdef": "def"}, {"fullname": "dp_tools.core.entity_model.DataDir.check_exists", "modulename": "dp_tools.core.entity_model", "qualname": "DataDir.check_exists", "type": "variable", "doc": "<p></p>\n", "annotation": ": bool", "default_value": " = True"}, {"fullname": "dp_tools.core.entity_model.CanAttachComponents", "modulename": "dp_tools.core.entity_model", "qualname": "CanAttachComponents", "type": "class", "doc": "<p></p>\n"}, {"fullname": "dp_tools.core.entity_model.CanAttachComponents.__init__", "modulename": "dp_tools.core.entity_model", "qualname": "CanAttachComponents.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "dp_tools.core.entity_model.CanAttachComponents.all_components", "modulename": "dp_tools.core.entity_model", "qualname": "CanAttachComponents.all_components", "type": "variable", "doc": "<p>Return a dictionary of components, including any empty slots</p>\n", "annotation": ": Dict[str, object]"}, {"fullname": "dp_tools.core.entity_model.CanAttachComponents.components", "modulename": "dp_tools.core.entity_model", "qualname": "CanAttachComponents.components", "type": "variable", "doc": "<p>Return a list of components, EXCLUDING any empty slots</p>\n", "annotation": ": List[object]"}, {"fullname": "dp_tools.core.entity_model.CanAttachComponents.attach_component", "modulename": "dp_tools.core.entity_model", "qualname": "CanAttachComponents.attach_component", "type": "function", "doc": "<p></p>\n", "signature": "(self, component, attr)", "funcdef": "def"}, {"fullname": "dp_tools.core.entity_model.AttachEntity", "modulename": "dp_tools.core.entity_model", "qualname": "AttachEntity", "type": "class", "doc": "<p></p>\n", "bases": "typing.TypedDict"}, {"fullname": "dp_tools.core.entity_model.CanAttachEntity", "modulename": "dp_tools.core.entity_model", "qualname": "CanAttachEntity", "type": "class", "doc": "<p></p>\n"}, {"fullname": "dp_tools.core.entity_model.CanAttachEntity.__init__", "modulename": "dp_tools.core.entity_model", "qualname": "CanAttachEntity.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "dp_tools.core.entity_model.CanAttachEntity.entities", "modulename": "dp_tools.core.entity_model", "qualname": "CanAttachEntity.entities", "type": "variable", "doc": "<p></p>\n", "annotation": ": Dict[str, dp_tools.core.entity_model.AttachEntity]", "default_value": " = None"}, {"fullname": "dp_tools.core.entity_model.CanAttachEntity.entityType", "modulename": "dp_tools.core.entity_model", "qualname": "CanAttachEntity.entityType", "type": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": " = None"}, {"fullname": "dp_tools.core.entity_model.CanAttachEntity.dataset", "modulename": "dp_tools.core.entity_model", "qualname": "CanAttachEntity.dataset", "type": "variable", "doc": "<p></p>\n", "annotation": ": dp_tools.core.entity_model.TemplateDataset"}, {"fullname": "dp_tools.core.entity_model.ModuleLevelMQC", "modulename": "dp_tools.core.entity_model", "qualname": "ModuleLevelMQC", "type": "class", "doc": "<p></p>\n", "bases": "typing.TypedDict"}, {"fullname": "dp_tools.core.entity_model.MQCTargetDict", "modulename": "dp_tools.core.entity_model", "qualname": "MQCTargetDict", "type": "class", "doc": "<p></p>\n", "bases": "typing.TypedDict"}, {"fullname": "dp_tools.core.entity_model.BaseComponent", "modulename": "dp_tools.core.entity_model", "qualname": "BaseComponent", "type": "class", "doc": "<p>Class for keeping track of abstract components like Reads, Alignments, and Counts</p>\n"}, {"fullname": "dp_tools.core.entity_model.BaseComponent.__init__", "modulename": "dp_tools.core.entity_model", "qualname": "BaseComponent.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    description: str = 'Null',\n    created: datetime.datetime = <factory>\n)", "funcdef": "def"}, {"fullname": "dp_tools.core.entity_model.BaseComponent.description", "modulename": "dp_tools.core.entity_model", "qualname": "BaseComponent.description", "type": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": " = 'Null'"}, {"fullname": "dp_tools.core.entity_model.TemplateComponent", "modulename": "dp_tools.core.entity_model", "qualname": "TemplateComponent", "type": "class", "doc": "<p>Helper class that provides a standard way to create an ABC using\ninheritance.</p>\n", "bases": "abc.ABC, CanAttachEntity"}, {"fullname": "dp_tools.core.entity_model.TemplateComponent.__init__", "modulename": "dp_tools.core.entity_model", "qualname": "TemplateComponent.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "dp_tools.core.entity_model.TemplateComponent.all_data_assets", "modulename": "dp_tools.core.entity_model", "qualname": "TemplateComponent.all_data_assets", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "dp_tools.core.entity_model.TemplateComponent.mqcData", "modulename": "dp_tools.core.entity_model", "qualname": "TemplateComponent.mqcData", "type": "variable", "doc": "<p></p>\n", "annotation": ": dict[str, dp_tools.core.entity_model.ModuleLevelMQC]"}, {"fullname": "dp_tools.core.entity_model.EmptyComponent", "modulename": "dp_tools.core.entity_model", "qualname": "EmptyComponent", "type": "class", "doc": "<p>Class representing an empty component</p>\n", "bases": "TemplateComponent"}, {"fullname": "dp_tools.core.entity_model.EmptyComponent.__init__", "modulename": "dp_tools.core.entity_model", "qualname": "EmptyComponent.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    base: dp_tools.core.entity_model.BaseComponent = BaseComponent(description='This slot is empty', created=datetime.datetime(2022, 5, 19, 13, 39, 51, 177585)),\n    _mqcData: bool = False\n)", "funcdef": "def"}, {"fullname": "dp_tools.core.entity_model.EmptyComponent.base", "modulename": "dp_tools.core.entity_model", "qualname": "EmptyComponent.base", "type": "variable", "doc": "<p></p>\n", "annotation": ": dp_tools.core.entity_model.BaseComponent", "default_value": " = BaseComponent(description='This slot is empty', created=datetime.datetime(2022, 5, 19, 13, 39, 51, 177585))"}, {"fullname": "dp_tools.core.entity_model.BaseDataSystem", "modulename": "dp_tools.core.entity_model", "qualname": "BaseDataSystem", "type": "class", "doc": "<p>Abstract class for a dataset\nNOTE: Within this system:\n    a dataset is associated with a specific assay\n    a dataSYSTEM is the container for multiple datasets</p>\n"}, {"fullname": "dp_tools.core.entity_model.BaseDataSystem.__init__", "modulename": "dp_tools.core.entity_model", "qualname": "BaseDataSystem.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    name: str,\n    datasets: Dict[str, dp_tools.core.entity_model.BaseDataset] = <factory>\n)", "funcdef": "def"}, {"fullname": "dp_tools.core.entity_model.TemplateDataSystem", "modulename": "dp_tools.core.entity_model", "qualname": "TemplateDataSystem", "type": "class", "doc": "<p>This abstract base class should serve as a template for new data systems</p>\n", "bases": "abc.ABC"}, {"fullname": "dp_tools.core.entity_model.TemplateDataSystem.__init__", "modulename": "dp_tools.core.entity_model", "qualname": "TemplateDataSystem.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "dp_tools.core.entity_model.TemplateDataSystem.name", "modulename": "dp_tools.core.entity_model", "qualname": "TemplateDataSystem.name", "type": "variable", "doc": "<p>Alias name to from compositioned base to implementation</p>\n"}, {"fullname": "dp_tools.core.entity_model.TemplateDataSystem.dataset", "modulename": "dp_tools.core.entity_model", "qualname": "TemplateDataSystem.dataset", "type": "variable", "doc": "<p>Convenience function when only one dataset is attached</p>\n"}, {"fullname": "dp_tools.core.entity_model.TemplateDataSystem.datasets", "modulename": "dp_tools.core.entity_model", "qualname": "TemplateDataSystem.datasets", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "dp_tools.core.entity_model.TemplateDataSystem.all_datasets", "modulename": "dp_tools.core.entity_model", "qualname": "TemplateDataSystem.all_datasets", "type": "variable", "doc": "<p>returns a set of all datasets</p>\n"}, {"fullname": "dp_tools.core.entity_model.TemplateDataSystem.all_samples", "modulename": "dp_tools.core.entity_model", "qualname": "TemplateDataSystem.all_samples", "type": "variable", "doc": "<p>returns a set of all samples</p>\n"}, {"fullname": "dp_tools.core.entity_model.TemplateDataSystem.all_components", "modulename": "dp_tools.core.entity_model", "qualname": "TemplateDataSystem.all_components", "type": "variable", "doc": "<p>returns a set of all components</p>\n"}, {"fullname": "dp_tools.core.entity_model.TemplateDataSystem.attach_dataset", "modulename": "dp_tools.core.entity_model", "qualname": "TemplateDataSystem.attach_dataset", "type": "function", "doc": "<p></p>\n", "signature": "(self, dataset)", "funcdef": "def"}, {"fullname": "dp_tools.core.entity_model.BaseDataset", "modulename": "dp_tools.core.entity_model", "qualname": "BaseDataset", "type": "class", "doc": "<p>Abstract class for a dataset\nNOTE: Within this system:\n    a dataset is associated with a specific assay\n    a dataSYSTEM is the container for multiple datasets</p>\n"}, {"fullname": "dp_tools.core.entity_model.BaseDataset.__init__", "modulename": "dp_tools.core.entity_model", "qualname": "BaseDataset.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    name: str = 'orphan',\n    samples: Dict[str, dp_tools.core.entity_model.BaseSample] = <factory>,\n    config: dict = <factory>\n)", "funcdef": "def"}, {"fullname": "dp_tools.core.entity_model.BaseDataset.name", "modulename": "dp_tools.core.entity_model", "qualname": "BaseDataset.name", "type": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": " = 'orphan'"}, {"fullname": "dp_tools.core.entity_model.TemplateDataset", "modulename": "dp_tools.core.entity_model", "qualname": "TemplateDataset", "type": "class", "doc": "<p>Helper class that provides a standard way to create an ABC using\ninheritance.</p>\n", "bases": "abc.ABC, CanAttachComponents"}, {"fullname": "dp_tools.core.entity_model.TemplateDataset.dataSystem", "modulename": "dp_tools.core.entity_model", "qualname": "TemplateDataset.dataSystem", "type": "variable", "doc": "<p></p>\n", "annotation": ": dp_tools.core.entity_model.TemplateDataSystem", "default_value": " = None"}, {"fullname": "dp_tools.core.entity_model.TemplateDataset.expected_sample_class", "modulename": "dp_tools.core.entity_model", "qualname": "TemplateDataset.expected_sample_class", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "dp_tools.core.entity_model.TemplateDataset.samples", "modulename": "dp_tools.core.entity_model", "qualname": "TemplateDataset.samples", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "dp_tools.core.entity_model.TemplateDataset.name", "modulename": "dp_tools.core.entity_model", "qualname": "TemplateDataset.name", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "dp_tools.core.entity_model.TemplateDataset.config", "modulename": "dp_tools.core.entity_model", "qualname": "TemplateDataset.config", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "dp_tools.core.entity_model.TemplateDataset.attach_sample", "modulename": "dp_tools.core.entity_model", "qualname": "TemplateDataset.attach_sample", "type": "function", "doc": "<p></p>\n", "signature": "(self, sample)", "funcdef": "def"}, {"fullname": "dp_tools.core.entity_model.TemplateDataset.all_non_empty_components_recursive", "modulename": "dp_tools.core.entity_model", "qualname": "TemplateDataset.all_non_empty_components_recursive", "type": "variable", "doc": "<p>returns a set of all components</p>\n"}, {"fullname": "dp_tools.core.entity_model.TemplateDataset.all_data_assets", "modulename": "dp_tools.core.entity_model", "qualname": "TemplateDataset.all_data_assets", "type": "variable", "doc": "<p>returns a set of all components</p>\n"}, {"fullname": "dp_tools.core.entity_model.TemplateDataset.getMQCDataFrame", "modulename": "dp_tools.core.entity_model", "qualname": "TemplateDataset.getMQCDataFrame", "type": "function", "doc": "<p>Generates a single dataframe composed of all samples for the requested component, mqc module, and plot.\nIf a mqc_plot is not specificed, a list of available plots is listed.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>sample_component</strong>:  The sample component attribute name</li>\n<li><strong>mqc_module</strong>:  The target components multiQC module name</li>\n<li><strong>mqc_plot</strong>:  The target components plot as generated by the requested multiQC module</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A dataframe with the index composed of sample names and the columns consistent with the original sample-wise multiQC plot dataframe</p>\n</blockquote>\n", "signature": "(\n    self,\n    sample_component: str,\n    mqc_module: str,\n    mqc_plot: str = None\n) -> Union[pandas.core.frame.DataFrame, List[str]]", "funcdef": "def"}, {"fullname": "dp_tools.core.entity_model.BaseSample", "modulename": "dp_tools.core.entity_model", "qualname": "BaseSample", "type": "class", "doc": "<p>Abstract class for samples</p>\n"}, {"fullname": "dp_tools.core.entity_model.BaseSample.__init__", "modulename": "dp_tools.core.entity_model", "qualname": "BaseSample.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    name: str,\n    dataset: Optional[dp_tools.core.entity_model.BaseDataset] = None\n)", "funcdef": "def"}, {"fullname": "dp_tools.core.entity_model.BaseSample.dataset", "modulename": "dp_tools.core.entity_model", "qualname": "BaseSample.dataset", "type": "variable", "doc": "<p></p>\n", "annotation": ": Optional[dp_tools.core.entity_model.BaseDataset]", "default_value": " = None"}, {"fullname": "dp_tools.core.entity_model.TemplateSample", "modulename": "dp_tools.core.entity_model", "qualname": "TemplateSample", "type": "class", "doc": "<p>Helper class that provides a standard way to create an ABC using\ninheritance.</p>\n", "bases": "abc.ABC, CanAttachComponents"}, {"fullname": "dp_tools.core.entity_model.TemplateSample.__init__", "modulename": "dp_tools.core.entity_model", "qualname": "TemplateSample.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "dp_tools.core.entity_model.TemplateSample.name", "modulename": "dp_tools.core.entity_model", "qualname": "TemplateSample.name", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "dp_tools.core.entity_model.TemplateSample.dataset", "modulename": "dp_tools.core.entity_model", "qualname": "TemplateSample.dataset", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "dp_tools.core.entity_model.GLDSDataSystem", "modulename": "dp_tools.core.entity_model", "qualname": "GLDSDataSystem", "type": "class", "doc": "<p>GLDSDataSystem(base: dp_tools.core.entity_model.BaseDataSystem)</p>\n", "bases": "TemplateDataSystem"}, {"fullname": "dp_tools.core.entity_model.GLDSDataSystem.__init__", "modulename": "dp_tools.core.entity_model", "qualname": "GLDSDataSystem.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, base: dp_tools.core.entity_model.BaseDataSystem)", "funcdef": "def"}, {"fullname": "dp_tools.core.model_commons", "modulename": "dp_tools.core.model_commons", "type": "module", "doc": "<p>Utilities common to all models in the package</p>\n"}, {"fullname": "dp_tools.core.model_commons.strict_type_checks", "modulename": "dp_tools.core.model_commons", "qualname": "strict_type_checks", "type": "function", "doc": "<p></p>\n", "signature": "(\n    obj: object,\n    exceptions: List[str] = None,\n    except_nones: List[str] = None\n)", "funcdef": "def"}, {"fullname": "dp_tools.core.post_processing", "modulename": "dp_tools.core.post_processing", "type": "module", "doc": "<p>Functions that take a data model and produce reporter files \nDepends on standard data asset metadata as loaded from packaged config files.</p>\n"}, {"fullname": "dp_tools.core.post_processing.load_config", "modulename": "dp_tools.core.post_processing", "qualname": "load_config", "type": "function", "doc": "<p></p>\n", "signature": "(\n    config: Union[tuple[str, str], pathlib.Path],\n    subsection: str = 'ISA Meta'\n) -> dict", "funcdef": "def"}, {"fullname": "dp_tools.core.post_processing.load_ISA_investigation_config", "modulename": "dp_tools.core.post_processing", "qualname": "load_ISA_investigation_config", "type": "function", "doc": "<p></p>\n", "signature": "() -> dict", "funcdef": "def"}, {"fullname": "dp_tools.core.post_processing.unmangle_columns", "modulename": "dp_tools.core.post_processing", "qualname": "unmangle_columns", "type": "function", "doc": "<p>Utility function to convert \"X.1...X.N\" into \"X...X\", reversing the normal column name mangle\nref: https://pandas.pydata.org/docs/reference/api/pandas.read_csv.html</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>columns</strong>:  Original mangled column names</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Unmangled columns names in same order</p>\n</blockquote>\n", "signature": "(columns: list[str]) -> list[str]", "funcdef": "def"}, {"fullname": "dp_tools.core.post_processing.get_assay_table_path", "modulename": "dp_tools.core.post_processing", "qualname": "get_assay_table_path", "type": "function", "doc": "<p>Retrieve the assay table file name that determined as a valid assay based on configuration.\nSpecifically, defined in subsection 'ISA meta'</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>dataset</strong>:  A dataset object including a metadata component with an attached ISA archive data asset</li>\n<li><strong>configuration</strong>:  Standard assay parsed config</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Path to the found assay table</p>\n</blockquote>\n", "signature": "(\n    dataset: dp_tools.core.entity_model.TemplateDataset,\n    configuration: dict\n) -> pathlib.Path", "funcdef": "def"}, {"fullname": "dp_tools.core.post_processing.generate_new_column_dicts", "modulename": "dp_tools.core.post_processing", "qualname": "generate_new_column_dicts", "type": "function", "doc": "<p>Based on data assets in the dataset and configuration, generates dictionaries for dataframe extension.\nSpecifically, the \"data assets\" configuration subsection is used.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>dataset</strong>:  A dataset object</li>\n<li><strong>configuration</strong>:  Standard assay parsed config</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Two dictionaries, the first with dataframe ready new data assets and the second denoting the intended order of those new columns</p>\n</blockquote>\n", "signature": "(\n    dataset: dp_tools.core.entity_model.TemplateDataset,\n    configuration: dict\n) -> tuple[dict, dict]", "funcdef": "def"}, {"fullname": "dp_tools.core.post_processing.extend_assay_dataframe", "modulename": "dp_tools.core.post_processing", "qualname": "extend_assay_dataframe", "type": "function", "doc": "<p></p>\n", "signature": "(\n    df_orignal: pandas.core.frame.DataFrame,\n    new_column_data: dict,\n    new_column_order: dict\n)", "funcdef": "def"}, {"fullname": "dp_tools.core.post_processing.sync_investigation_and_assay_dataframes", "modulename": "dp_tools.core.post_processing", "qualname": "sync_investigation_and_assay_dataframes", "type": "function", "doc": "<p></p>\n", "signature": "(df_investigation, column_contents, column_order, configuration)", "funcdef": "def"}, {"fullname": "dp_tools.core.post_processing.get_parameter_values", "modulename": "dp_tools.core.post_processing", "qualname": "get_parameter_values", "type": "function", "doc": "<p>Extract the value from parameter value columns.\nSuch that 'Parameter Value[someVal]' gives 'someVal'\nThese are associated with the first preceeding\n\"Protocol REF\" column (which is likely mangled by pandas)</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>df</strong>:  A dataframe representing an assay or sample table from the ISA spec</li>\n<li><strong>drop_ontology</strong>:  In legacy data,</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A mapping of parameter values to their protocol</p>\n</blockquote>\n", "signature": "(\n    df: pandas.core.frame.DataFrame,\n    drop_ontology: bool = True\n) -> dict[str, list]", "funcdef": "def"}, {"fullname": "dp_tools.core.post_processing.add_protocol", "modulename": "dp_tools.core.post_processing", "qualname": "add_protocol", "type": "function", "doc": "<p></p>\n", "signature": "(\n    df_investigation: pandas.core.frame.DataFrame,\n    protocol_key: str,\n    df_assay: Optional[pandas.core.frame.DataFrame] = None\n)", "funcdef": "def"}, {"fullname": "dp_tools.core.post_processing.setup_output_target", "modulename": "dp_tools.core.post_processing", "qualname": "setup_output_target", "type": "function", "doc": "<p>Set ups target output file location.  Uses specified output_file name if provided.\nDefaults to the original table filename but saves to a directory 'output_dir' in either case.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>output_file</strong>:  Specifies an alternative output filename for the extended table</li>\n<li><strong>original_path</strong>:  Specifies the orignal path, used to determine a default filename.</li>\n<li><strong>output_dir</strong>:  Specifies the name of the directory for the output file, defaults to \"updated_tables\"</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>The output target location.</p>\n</blockquote>\n", "signature": "(\n    output_file: Optional[str],\n    original_path: pathlib.Path,\n    output_dir: str = 'updated_curation_tables'\n) -> pathlib.Path", "funcdef": "def"}, {"fullname": "dp_tools.core.post_processing.update_curation_tables", "modulename": "dp_tools.core.post_processing", "qualname": "update_curation_tables", "type": "function", "doc": "<p>Updates existing curation investigation and assay tables with processed data.\nThis function extends the existing assay table with processing data assets.\nThe naming and order of the new columns is configured in the data assets config section.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>dataset</strong>:  A loaded dataset object</li>\n<li><strong>config: A assay type configuration file specifier formatted as follows</strong>:  ('assay','version') or local path to configuration file</li>\n<li><strong>output_file</strong>:  The name of the updated output tables, defaults to using the same name as the original tables</li>\n<li><strong>investigation_table</strong>:  Controls the updating and syncing of the investigation table, defaults to False</li>\n</ul>\n", "signature": "(\n    dataset: dp_tools.core.entity_model.TemplateDataset,\n    config: Union[tuple[str, str], pathlib.Path],\n    output_file: str = None,\n    investigation_table: bool = False\n)", "funcdef": "def"}, {"fullname": "dp_tools.core.utilites", "modulename": "dp_tools.core.utilites", "type": "module", "doc": "<p></p>\n"}, {"fullname": "dp_tools.core.utilites.multiqc_tools", "modulename": "dp_tools.core.utilites.multiqc_tools", "type": "module", "doc": "<p></p>\n"}, {"fullname": "dp_tools.core.utilites.multiqc_tools.clean_messy_sample", "modulename": "dp_tools.core.utilites.multiqc_tools", "qualname": "clean_messy_sample", "type": "function", "doc": "<p></p>\n", "signature": "(messy_sample: str)", "funcdef": "def"}, {"fullname": "dp_tools.core.utilites.multiqc_tools.get_reformated_source_dict", "modulename": "dp_tools.core.utilites.multiqc_tools", "qualname": "get_reformated_source_dict", "type": "function", "doc": "<p></p>\n", "signature": "(source_dict: dict)", "funcdef": "def"}, {"fullname": "dp_tools.core.utilites.multiqc_tools.get_parsed_data", "modulename": "dp_tools.core.utilites.multiqc_tools", "qualname": "get_parsed_data", "type": "function", "doc": "<p></p>\n", "signature": "(\n    input_f: List[str],\n    modules: List[str] = [],\n    as_dataframe: bool = True\n)", "funcdef": "def"}, {"fullname": "dp_tools.core.utilites.multiqc_tools.flatten_raw_data", "modulename": "dp_tools.core.utilites.multiqc_tools", "qualname": "flatten_raw_data", "type": "function", "doc": "<p>Generates a raw data flat dictionary from the full nested mqc report</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>mqc_rep</strong>:  [description]</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>[description]</p>\n</blockquote>\n", "signature": "(mqc_rep: dict) -> dict", "funcdef": "def"}, {"fullname": "dp_tools.core.utilites.multiqc_tools.MQCRunDict", "modulename": "dp_tools.core.utilites.multiqc_tools", "qualname": "MQCRunDict", "type": "class", "doc": "<p></p>\n", "bases": "typing.TypedDict"}, {"fullname": "dp_tools.core.utilites.multiqc_tools.get_general_stats", "modulename": "dp_tools.core.utilites.multiqc_tools", "qualname": "get_general_stats", "type": "function", "doc": "<p></p>\n", "signature": "(\n    mqc_run_output: dp_tools.core.utilites.multiqc_tools.MQCRunDict\n) -> dict[str, dict]", "funcdef": "def"}, {"fullname": "dp_tools.core.utilites.multiqc_tools.format_plots_as_dataframe", "modulename": "dp_tools.core.utilites.multiqc_tools", "qualname": "format_plots_as_dataframe", "type": "function", "doc": "<p></p>\n", "signature": "(\n    mqc_rep: dp_tools.core.utilites.multiqc_tools.MQCRunDict\n) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "dp_tools.core.utilites.multiqc_tools.parse_bar_graph_to_flat_dict", "modulename": "dp_tools.core.utilites.multiqc_tools", "qualname": "parse_bar_graph_to_flat_dict", "type": "function", "doc": "<p></p>\n", "signature": "(plot_data)", "funcdef": "def"}, {"fullname": "dp_tools.core.utilites.multiqc_tools.format_plot_data", "modulename": "dp_tools.core.utilites.multiqc_tools", "qualname": "format_plot_data", "type": "function", "doc": "<p></p>\n", "signature": "(mqc_rep: dict)", "funcdef": "def"}, {"fullname": "dp_tools.glds_api", "modulename": "dp_tools.glds_api", "type": "module", "doc": "<p></p>\n"}, {"fullname": "dp_tools.glds_api.commons", "modulename": "dp_tools.glds_api.commons", "type": "module", "doc": "<p></p>\n"}, {"fullname": "dp_tools.glds_api.commons.read_json", "modulename": "dp_tools.glds_api.commons", "qualname": "read_json", "type": "function", "doc": "<p></p>\n", "signature": "(url)", "funcdef": "def"}, {"fullname": "dp_tools.glds_api.commons.get_glds_filelisting_json", "modulename": "dp_tools.glds_api.commons", "qualname": "get_glds_filelisting_json", "type": "function", "doc": "<p>Return filelisting json accession number</p>\n", "signature": "(accession: str) -> tuple[dict, str]", "funcdef": "def"}, {"fullname": "dp_tools.glds_api.files", "modulename": "dp_tools.glds_api.files", "type": "module", "doc": "<p>Module for finding file urls as hosted on the GLDS repository</p>\n"}, {"fullname": "dp_tools.glds_api.files.get_valid_url", "modulename": "dp_tools.glds_api.files", "qualname": "get_valid_url", "type": "function", "doc": "<p></p>\n", "signature": "(fn: str, version: str) -> str", "funcdef": "def"}, {"fullname": "dp_tools.glds_api.files.reformat_filelisting", "modulename": "dp_tools.glds_api.files", "qualname": "reformat_filelisting", "type": "function", "doc": "<p>Reformats the original file listing</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>original_json</strong>:  _description_</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>_description_</p>\n</blockquote>\n", "signature": "(original_json: dict) -> dict", "funcdef": "def"}, {"fullname": "dp_tools.glds_api.files.get_urls", "modulename": "dp_tools.glds_api.files", "qualname": "get_urls", "type": "function", "doc": "<p></p>\n", "signature": "(accession: str) -> dict[str, str]", "funcdef": "def"}, {"fullname": "dp_tools.glds_api.files.associate_url_for_data_file", "modulename": "dp_tools.glds_api.files", "qualname": "associate_url_for_data_file", "type": "function", "doc": "<p></p>\n", "signature": "(\n    entity: Union[dp_tools.core.entity_model.TemplateDataset, dp_tools.core.entity_model.TemplateSample],\n    target_asset: dp_tools.core.entity_model.DataFile\n) -> str", "funcdef": "def"}, {"fullname": "dp_tools.glds_api.isa", "modulename": "dp_tools.glds_api.isa", "type": "module", "doc": "<p></p>\n"}, {"fullname": "dp_tools.glds_api.isa.get_isa", "modulename": "dp_tools.glds_api.isa", "qualname": "get_isa", "type": "function", "doc": "<p>Returns isa filename as well as GeneLab URLS from the associated file listing</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>accession</strong>:  GLDS accession ID, e.g. GLDS-194</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>:  \"Malformed JSON?\" if there is an issue getting the filelisting url 'id'</li>\n<li><strong>ValueError: \"Unexpected</strong>:  no ISAs found\"</li>\n<li><strong>ValueError: \"Unexpected</strong>:  multiple files match the ISA regex\"</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A tuple as follows: [filename, version_id, url, alternative_url]</p>\n</blockquote>\n", "signature": "(accession: str) -> tuple[str, str, str, str]", "funcdef": "def"}, {"fullname": "dp_tools.glds_api.isa.download_isa", "modulename": "dp_tools.glds_api.isa", "qualname": "download_isa", "type": "function", "doc": "<p>Downloads the ISA archive for the given GLDS accession number.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>accession</strong>:  GLDS accession number, e.g. GLDS-194</li>\n<li><strong>alternate_url</strong>:  Designates if the alternative url should be used, both fetch the same file, defaults to False</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>The filename as downloaded to the local drive</p>\n</blockquote>\n", "signature": "(accession: str, alternate_url: bool = False) -> str", "funcdef": "def"}, {"fullname": "dp_tools.glds_api.isa.main", "modulename": "dp_tools.glds_api.isa", "qualname": "main", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "dp_tools.scripts", "modulename": "dp_tools.scripts", "type": "module", "doc": "<p></p>\n"}, {"fullname": "dp_tools.scripts.convert", "modulename": "dp_tools.scripts.convert", "type": "module", "doc": "<p></p>\n"}, {"fullname": "dp_tools.scripts.convert.isa_investigation_subtables", "modulename": "dp_tools.scripts.convert", "qualname": "isa_investigation_subtables", "type": "function", "doc": "<p></p>\n", "signature": "(ISAarchive: pathlib.Path) -> dict[str, pandas.core.frame.DataFrame]", "funcdef": "def"}, {"fullname": "dp_tools.scripts.convert.get_assay_table_path", "modulename": "dp_tools.scripts.convert", "qualname": "get_assay_table_path", "type": "function", "doc": "<p>Retrieve the assay table file name that determined as a valid assay based on configuration.\nSpecifically, defined in subsection 'ISA meta'</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>study_assay_table</strong>:  From the investigation file</li>\n<li><strong>configuration</strong>:  Standard assay parsed config</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Path to the found assay table</p>\n</blockquote>\n", "signature": "(\n    ISAarchive: pathlib.Path,\n    configuration: dict,\n    return_index: bool = False\n) -> pathlib.Path", "funcdef": "def"}, {"fullname": "dp_tools.scripts.convert.main", "modulename": "dp_tools.scripts.convert", "qualname": "main", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "dp_tools.scripts.convert.get_column_name", "modulename": "dp_tools.scripts.convert", "qualname": "get_column_name", "type": "function", "doc": "<p></p>\n", "signature": "(df: pandas.core.frame.DataFrame, target: Union[str, list]) -> str", "funcdef": "def"}, {"fullname": "dp_tools.scripts.convert.isa_to_runsheet", "modulename": "dp_tools.scripts.convert", "qualname": "isa_to_runsheet", "type": "function", "doc": "<p></p>\n", "signature": "(accession: str, isa_archive: pathlib.Path, config: tuple[str, str])", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();